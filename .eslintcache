[{"/Users/gilbertosanchez/pathfinder_visualizer/src/App.js":"1","/Users/gilbertosanchez/pathfinder_visualizer/src/algorithms/dijkstra.js":"2","/Users/gilbertosanchez/pathfinder_visualizer/src/algorithms/bfs.js":"3","/Users/gilbertosanchez/pathfinder_visualizer/src/Notification/Carousel.js":"4","/Users/gilbertosanchez/pathfinder_visualizer/src/Notification/Items.js":"5","/Users/gilbertosanchez/pathfinder_visualizer/src/Notification/Slider.js":"6","/Users/gilbertosanchez/pathfinder_visualizer/src/PathfindingVisualizer/PathfindingVisualizer.jsx":"7","/Users/gilbertosanchez/pathfinder_visualizer/src/algorithms/astar.js":"8","/Users/gilbertosanchez/pathfinder_visualizer/src/reportWebVitals.js":"9","/Users/gilbertosanchez/pathfinder_visualizer/src/Maze/recursiveDivMaze.js":"10","/Users/gilbertosanchez/pathfinder_visualizer/src/PathfindingVisualizer/Node/Node.jsx":"11","/Users/gilbertosanchez/pathfinder_visualizer/src/algorithms/dfs.js":"12","/Users/gilbertosanchez/pathfinder_visualizer/src/index.js":"13","/Users/gilbertosanchez/pathfinder_visualizer/src/notes/messageForm.js":"14","/Users/gilbertosanchez/pathfinder_visualizer/src/notes/messageBoard.js":"15","/Users/gilbertosanchez/pathfinder_visualizer/src/notes/messageComponent.js":"16","/Users/gilbertosanchez/pathfinder_visualizer/src/notes/singleComment.js":"17","/Users/gilbertosanchez/pathfinder_visualizer/src/notes/MessageComponent.js":"18","/Users/gilbertosanchez/pathfinder_visualizer/src/Notes/MessageForm.js":"19","/Users/gilbertosanchez/pathfinder_visualizer/src/Notes/MessageBoard.js":"20","/Users/gilbertosanchez/pathfinder_visualizer/src/Notes/MessageComponent.js":"21","/Users/gilbertosanchez/pathfinder_visualizer/src/Notes/SingleComment.js":"22"},{"size":278,"mtime":1607892759199,"results":"23","hashOfConfig":"24"},{"size":6368,"mtime":1614457970446,"results":"25","hashOfConfig":"24"},{"size":2039,"mtime":1613599844306,"results":"26","hashOfConfig":"24"},{"size":170,"mtime":1612468709757,"results":"27","hashOfConfig":"24"},{"size":3217,"mtime":1614549876416,"results":"28","hashOfConfig":"24"},{"size":1821,"mtime":1614481025431,"results":"29","hashOfConfig":"24"},{"size":38420,"mtime":1627020349982,"results":"30","hashOfConfig":"24"},{"size":6807,"mtime":1614480920159,"results":"31","hashOfConfig":"24"},{"size":362,"mtime":1606768651357,"results":"32","hashOfConfig":"24"},{"size":3480,"mtime":1613423115270,"results":"33","hashOfConfig":"24"},{"size":741,"mtime":1614461686750,"results":"34","hashOfConfig":"24"},{"size":1832,"mtime":1614480968125,"results":"35","hashOfConfig":"24"},{"size":500,"mtime":1606768651351,"results":"36","hashOfConfig":"24"},{"size":1365,"mtime":1627004795744,"results":"37","hashOfConfig":"24"},{"size":628,"mtime":1627004839298,"results":"38","hashOfConfig":"24"},{"size":686,"mtime":1627004825376,"results":"39","hashOfConfig":"24"},{"size":398,"mtime":1627004858108,"results":"40","hashOfConfig":"24"},{"size":686,"mtime":1627019777637,"results":"41","hashOfConfig":"24"},{"size":1365,"mtime":1627020372902,"results":"42","hashOfConfig":"24"},{"size":629,"mtime":1627020395411,"results":"43","hashOfConfig":"24"},{"size":686,"mtime":1627020446675,"results":"44","hashOfConfig":"24"},{"size":398,"mtime":1627020914713,"results":"45","hashOfConfig":"24"},{"filePath":"46","messages":"47","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"48"},"1b9c5ul",{"filePath":"49","messages":"50","errorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"51","messages":"52","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"53"},{"filePath":"54","messages":"55","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"56"},{"filePath":"57","messages":"58","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"53"},{"filePath":"59","messages":"60","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"56"},{"filePath":"61","messages":"62","errorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"63","messages":"64","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"65","usedDeprecatedRules":"53"},{"filePath":"66","messages":"67","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"53"},{"filePath":"68","messages":"69","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"48"},{"filePath":"70","messages":"71","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"72"},{"filePath":"73","messages":"74","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"56"},{"filePath":"75","messages":"76","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"77"},{"filePath":"78","messages":"79","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"80","messages":"81","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"82","messages":"83","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"84","messages":"85","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"86","messages":"87","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"88","messages":"89","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"90","messages":"91","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"92","messages":"93","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"53"},{"filePath":"94","messages":"95","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"/Users/gilbertosanchez/pathfinder_visualizer/src/App.js",[],["96","97"],"/Users/gilbertosanchez/pathfinder_visualizer/src/algorithms/dijkstra.js",["98","99","100"],"/Users/gilbertosanchez/pathfinder_visualizer/src/algorithms/bfs.js",[],["101","102"],"/Users/gilbertosanchez/pathfinder_visualizer/src/Notification/Carousel.js",[],["103","104"],"/Users/gilbertosanchez/pathfinder_visualizer/src/Notification/Items.js",[],"/Users/gilbertosanchez/pathfinder_visualizer/src/Notification/Slider.js",[],"/Users/gilbertosanchez/pathfinder_visualizer/src/PathfindingVisualizer/PathfindingVisualizer.jsx",["105","106","107"],"/Users/gilbertosanchez/pathfinder_visualizer/src/algorithms/astar.js",["108","109"],"//astar algo\n//need to add the (g,f,h) properties to each node \n//g - cost of path\n//h - distance from current node to end node\n//f - g+h\n\nexport function astar(grid, startNode, finishNode) {\n    const visitedNodes = [];\n    startNode.h = heuristicManhattan(startNode, finishNode)\n    startNode.g = 0\n\n    let openHeap = new BinaryHeap(function (node) {return node.f});\n    openHeap.push(startNode)\n    while (!!openHeap.content.length){\n      //use heap to get the node with the lowest cost\n      const currentNode = openHeap.pop();\n      currentNode.closed = true\n      visitedNodes.push(currentNode)\n      if (currentNode === finishNode) return visitedNodes\n      \n      openHeap = updateUnvisitedNeighbors(currentNode, grid, finishNode, openHeap)\n\n    }\n    return visitedNodes;\n}\n\n\n\n    function heuristicManhattan(pos0, pos1) {\n        const d1 = Math.abs(pos1.row - pos0.row);\n        const d2 = Math.abs(pos1.col - pos0.col);\n        return d1 + d2;\n      }\n\n    function updateUnvisitedNeighbors(node, grid, end, heap) {\n      const unvisitedNeighbors = getUnvisitedNeighbors(node, grid);\n      for (const neighbor of unvisitedNeighbors) {\n        if (neighbor.closed || neighbor.isWall) continue;\n        let newGScore = node.g + neighbor.weight\n        const beenVisited = neighbor.isVisited\n        if (neighbor.isVisited === false || newGScore<neighbor.g){\n          neighbor.isVisited = true\n          neighbor.g = newGScore\n          neighbor.previousNode = node;\n          neighbor.h = heuristicManhattan(neighbor, end);\n          neighbor.f = neighbor.g + neighbor.h\n\n          if (!beenVisited){\n            heap.push(neighbor);\n          }else {\n            heap.rescoreElement(neighbor);\n          }\n        }\n\n      }\n\n      return heap;\n    }\n    \n    function getUnvisitedNeighbors(node, grid) {\n      const neighbors = [];\n      const {col, row} = node;\n      //push node above current cell\n      if (row > 0) neighbors.push(grid[row - 1][col]);\n      //push node below current cell \n      if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\n      //push node to the left of current cell \n      if (col > 0) neighbors.push(grid[row][col - 1]);\n      //push node to the right of current cell\n      if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\n      return neighbors; \n    }\n\n\n    function BinaryHeap(scoreFunction){\n      this.content = [];\n      this.scoreFunction = scoreFunction;\n    }\n    \n    BinaryHeap.prototype = {\n      push: function(element) {\n        // Add the new element to the end of the array.\n        this.content.push(element);\n        // Allow it to bubble up.\n        this.bubbleUp(this.content.length - 1);\n      },\n    \n      pop: function() {\n        // Store the first element so we can return it later.\n        var result = this.content[0];\n        // Get the element at the end of the array.\n        var end = this.content.pop();\n        // If there are any elements left, put the end element at the\n        // start, and let it sink down.\n        if (this.content.length > 0) {\n          this.content[0] = end;\n          this.sinkDown(0);\n        }\n        return result;\n      },\n    \n      remove: function(node) {\n        var length = this.content.length;\n        // To remove a value, we must search through the array to find\n        // it.\n        for (var i = 0; i < length; i++) {\n          if (this.content[i] != node) continue;\n          // When it is found, the process seen in 'pop' is repeated\n          // to fill up the hole.\n          var end = this.content.pop();\n          // If the element we popped was the one we needed to remove,\n          // we're done.\n          if (i == length - 1) break;\n          // Otherwise, we replace the removed element with the popped\n          // one, and allow it to float up or sink down as appropriate.\n          this.content[i] = end;\n          this.bubbleUp(i);\n          this.sinkDown(i);\n          break;\n        }\n      },\n    \n      size: function() {\n        return this.content.length;\n      },\n\n      rescoreElement: function(node) {\n        this.sinkDown(this.content.indexOf(node));\n      },\n\n      bubbleUp: function(n) {\n        // Fetch the element that has to be moved.\n        var element = this.content[n], score = this.scoreFunction(element);\n        // When at 0, an element can not go up any further.\n        while (n > 0) {\n          // Compute the parent element's index, and fetch it.\n          var parentN = Math.floor((n + 1) / 2) - 1,\n          parent = this.content[parentN];\n          // If the parent has a lesser score, things are in order and we\n          // are done.\n          if (score > this.scoreFunction(parent))\n            break;\n    \n          // Otherwise, swap the parent with the current element and\n          // continue.\n          this.content[parentN] = element;\n          this.content[n] = parent;\n          n = parentN;\n        }\n      },\n    \n      sinkDown: function(n) {\n        // Look up the target element and its score.\n        var length = this.content.length,\n        element = this.content[n],\n        elemScore = this.scoreFunction(element);\n    \n        while(true) {\n          // Compute the indices of the child elements.\n          var child2N = (n + 1) * 2, child1N = child2N - 1;\n          // This is used to store the new position of the element,\n          // if any.\n          var swap = null;\n          // If the first child exists (is inside the array)...\n          if (child1N < length) {\n            // Look it up and compute its score.\n            var child1 = this.content[child1N],\n            child1Score = this.scoreFunction(child1);\n            // If the score is less than our element's, we need to swap.\n            if (child1Score < elemScore)\n              swap = child1N;\n          }\n          // Do the same checks for the other child.\n          if (child2N < length) {\n            var child2 = this.content[child2N],\n            child2Score = this.scoreFunction(child2);\n            if (child2Score < (swap == null ? elemScore : child1Score))\n              swap = child2N;\n          }\n    \n          // No need to swap further, we are done.\n          if (swap == null) break;\n    \n          // Otherwise, swap and continue.\n          this.content[n] = this.content[swap];\n          this.content[swap] = element;\n          n = swap;\n        }\n      }\n    }\n    \n  // Backtracks from the finishNode to find the shortest path.\n  export function getNodesInShortestPathOrderAstar(finishNode) {\n    const nodesInShortestPathOrder = [];\n    let currentNode = finishNode;\n    while (currentNode !== null) {\n      nodesInShortestPathOrder.unshift(currentNode);\n      currentNode.isShortestPath = true;\n      currentNode = currentNode.previousNode;\n    }\n    return nodesInShortestPathOrder;\n  }\n\n","/Users/gilbertosanchez/pathfinder_visualizer/src/reportWebVitals.js",[],"/Users/gilbertosanchez/pathfinder_visualizer/src/Maze/recursiveDivMaze.js",[],"/Users/gilbertosanchez/pathfinder_visualizer/src/PathfindingVisualizer/Node/Node.jsx",[],["110","111"],"/Users/gilbertosanchez/pathfinder_visualizer/src/algorithms/dfs.js",[],"/Users/gilbertosanchez/pathfinder_visualizer/src/index.js",[],["112","113"],"/Users/gilbertosanchez/pathfinder_visualizer/src/notes/messageForm.js",[],"/Users/gilbertosanchez/pathfinder_visualizer/src/notes/messageBoard.js",[],"/Users/gilbertosanchez/pathfinder_visualizer/src/notes/messageComponent.js",[],"/Users/gilbertosanchez/pathfinder_visualizer/src/notes/singleComment.js",[],"/Users/gilbertosanchez/pathfinder_visualizer/src/notes/MessageComponent.js",[],"/Users/gilbertosanchez/pathfinder_visualizer/src/Notes/MessageForm.js",[],"/Users/gilbertosanchez/pathfinder_visualizer/src/Notes/MessageBoard.js",[],"/Users/gilbertosanchez/pathfinder_visualizer/src/Notes/MessageComponent.js",[],"/Users/gilbertosanchez/pathfinder_visualizer/src/Notes/SingleComment.js",[],{"ruleId":"114","replacedBy":"115"},{"ruleId":"116","replacedBy":"117"},{"ruleId":"118","severity":1,"message":"119","line":94,"column":29,"nodeType":"120","messageId":"121","endLine":94,"endColumn":31},{"ruleId":"118","severity":1,"message":"122","line":100,"column":15,"nodeType":"120","messageId":"121","endLine":100,"endColumn":17},{"ruleId":"123","severity":1,"message":"124","line":181,"column":12,"nodeType":"125","messageId":"126","endLine":181,"endColumn":23},{"ruleId":"114","replacedBy":"127"},{"ruleId":"116","replacedBy":"128"},{"ruleId":"114","replacedBy":"129"},{"ruleId":"116","replacedBy":"130"},{"ruleId":"118","severity":1,"message":"122","line":381,"column":23,"nodeType":"120","messageId":"121","endLine":381,"endColumn":25},{"ruleId":"118","severity":1,"message":"122","line":405,"column":36,"nodeType":"120","messageId":"121","endLine":405,"endColumn":38},{"ruleId":"118","severity":1,"message":"122","line":428,"column":36,"nodeType":"120","messageId":"121","endLine":428,"endColumn":38},{"ruleId":"118","severity":1,"message":"119","line":107,"column":31,"nodeType":"120","messageId":"121","endLine":107,"endColumn":33},{"ruleId":"118","severity":1,"message":"122","line":113,"column":17,"nodeType":"120","messageId":"121","endLine":113,"endColumn":19},{"ruleId":"114","replacedBy":"131"},{"ruleId":"116","replacedBy":"132"},{"ruleId":"114","replacedBy":"133"},{"ruleId":"116","replacedBy":"134"},"no-native-reassign",["135"],"no-negated-in-lhs",["136"],"eqeqeq","Expected '!==' and instead saw '!='.","BinaryExpression","unexpected","Expected '===' and instead saw '=='.","no-unused-vars","'getAllNodes' is defined but never used.","Identifier","unusedVar",["135"],["136"],["135"],["136"],["135"],["136"],["135"],["136"],"no-global-assign","no-unsafe-negation"]