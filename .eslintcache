[{"/Users/gilbertosanchez/pathfinder_visualizer/src/App.js":"1","/Users/gilbertosanchez/pathfinder_visualizer/src/algorithms/dijkstra.js":"2","/Users/gilbertosanchez/pathfinder_visualizer/src/algorithms/bfs.js":"3","/Users/gilbertosanchez/pathfinder_visualizer/src/Notification/Carousel.js":"4","/Users/gilbertosanchez/pathfinder_visualizer/src/Notification/Items.js":"5","/Users/gilbertosanchez/pathfinder_visualizer/src/Notification/Slider.js":"6","/Users/gilbertosanchez/pathfinder_visualizer/src/PathfindingVisualizer/PathfindingVisualizer.jsx":"7","/Users/gilbertosanchez/pathfinder_visualizer/src/algorithms/astar.js":"8"},{"size":278,"mtime":1607892759199,"results":"9","hashOfConfig":"10"},{"size":2609,"mtime":1613599889701,"results":"11","hashOfConfig":"10"},{"size":2039,"mtime":1613599844306,"results":"12","hashOfConfig":"10"},{"size":170,"mtime":1612468709757,"results":"13","hashOfConfig":"10"},{"size":2540,"mtime":1613600099187,"results":"14","hashOfConfig":"10"},{"size":2933,"mtime":1614288941437,"results":"15","hashOfConfig":"10"},{"size":32536,"mtime":1613761290347,"results":"16","hashOfConfig":"10"},{"size":6864,"mtime":1613599833690,"results":"17","hashOfConfig":"10"},{"filePath":"18","messages":"19","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"20"},"1b9c5ul",{"filePath":"21","messages":"22","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"20"},{"filePath":"23","messages":"24","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"25","messages":"26","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"27","messages":"28","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"29","messages":"30","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"31","messages":"32","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"33","usedDeprecatedRules":"20"},{"filePath":"34","messages":"35","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},"/Users/gilbertosanchez/pathfinder_visualizer/src/App.js",[],["36","37"],"/Users/gilbertosanchez/pathfinder_visualizer/src/algorithms/dijkstra.js",[],"/Users/gilbertosanchez/pathfinder_visualizer/src/algorithms/bfs.js",[],"/Users/gilbertosanchez/pathfinder_visualizer/src/Notification/Carousel.js",[],"/Users/gilbertosanchez/pathfinder_visualizer/src/Notification/Items.js",[],"/Users/gilbertosanchez/pathfinder_visualizer/src/Notification/Slider.js",[],"/Users/gilbertosanchez/pathfinder_visualizer/src/PathfindingVisualizer/PathfindingVisualizer.jsx",["38"],"import React, {Component} from 'react';\nimport Node from './Node/Node';\nimport {dijkstra, getNodesInShortestPathOrderDijkstra} from '../algorithms/dijkstra';\nimport {dfs, getNodesInShortestPathOrderDfs} from '../algorithms/dfs';\nimport {bfs, getNodesInShortestPathOrderBfs} from '../algorithms/bfs';\nimport {astar, getNodesInShortestPathOrderAstar} from '../algorithms/astar';\nimport {recursiveDivisionMaze} from '../Maze/recursiveDivMaze';\nimport {Carousel} from '../Notification/Carousel';\nimport '../Navbar/Navbar.css';\nimport './PathfindingVisualizer.css';\n\n// const START_ROW = 10;\n// const START_COL = 15;\n// const END_ROW = 10;\n// const END_COL = 35;\n// const objectTargetStatus = ['node node-start', 'node node-finish'];\n// const objectPathStatus = [\"node node-visited\", \"node node-shortest-path\", \"node node-wall\"]\n\nexport default class PathfindingVisualizer extends Component {\n  constructor() {\n    super();\n    this.state = {\n      grid: [],\n      mouseIsPressed: false,\n      startRow : 8,\n      startCol : 15,\n      endRow : 8,\n      endCol : 35,\n      start: false,\n      wall: false,\n      end: false,\n      algoDone: false,\n      algoType: ''\n    };\n  } \n\n\n  componentDidMount() {\n    const grid = this.getInitialGrid();\n    this.setState({grid});\n  };\n\n\n  shouldComponentUpdate(prevProps, prevState){\n    if(prevState.algoDone === false){\n      return true\n    }else {\n      return false\n    }\n  }\n  getInitialGrid = () => {\n    const grid = [];\n    for (let row = 0; row <16; row++) {\n      const currentRow = [];\n      for (let col = 0; col < 50; col++) {\n        currentRow.push(this.createNode(col, row));\n      }\n      grid.push(currentRow);\n    }  \n    return grid;\n  }\n  createNode = (col, row) => {\n    return {\n      col,\n      row,\n      isStart: row === this.state.startRow && col === this.state.startCol,\n      isFinish: row === this.state.endRow && col === this.state.endCol,\n      distance: Infinity,\n      isVisited: false,\n      isShortestPath: false,\n      isWall: false,\n      previousNode: null,\n      g : Infinity,\n      f : 0,\n      h : 0,\n      closed: false\n    };\n  };\n\n  resetBoard = () => {\n    const grid = this.getInitialGrid();\n\n    this.setState({grid:grid,\n      start: false,\n      wall: false,\n      end: false,\n      algoDone: false,\n      algoType: ''});\n\n    for (const row of grid){\n      for (const node of row){\n        if (node.isStart){\n          document.getElementById(`node-${node.row}-${node.col}`).className = 'node node-start'\n        }else if (node.isFinish){\n          document.getElementById(`node-${node.row}-${node.col}`).className = 'node node-finish'\n        }else{\n          document.getElementById(`node-${node.row}-${node.col}`).className = 'node'\n        }\n      }\n    }\n    return grid;\n  }\n\n  getNewStartWithToggle = (grid, row, col) => {\n    const newGrid = grid.slice();\n    const currStart = newGrid[this.state.startRow][this.state.startCol];\n    const newStart = newGrid[row][col];\n    if (row !== this.state.startRow || col !== this.state.startCol){\n      currStart.isStart = false;\n      newStart.isStart = true;\n      this.setState({startRow: row, startCol: col});\n    }\n\n    return newGrid;\n  }\n\n\n\n  getNewTargetwithToggle = (grid, row, col) => {\n    const newGrid = grid.slice();\n    const currEnd = newGrid[this.state.endRow][this.state.endCol];\n    const newEnd = newGrid[row][col];\n    if (row !== this.state.endRow || col !== this.state.endCol){\n      currEnd.isFinish = false;\n      newEnd.isFinish= true;\n      this.setState({endRow: row, endCol: col});\n    }\n\n    return newGrid;\n  }\n\n  getNewStartWithAlgo = (grid,row, col) => {\n    if(grid[row][col].isWall) return;\n    const gridCopy = grid.slice();\n    let startNode = null;\n    let finishNode = null;\n    for (const rows of gridCopy){\n      for (const node of rows){\n        if (!node.isWall){\n          node.isStart = false;\n          node.distance = Infinity;\n          node.isVisited = false;\n          node.isShortestPath = false;\n          node.previousNode = null;\n          node.g = Infinity;\n          node.f = 0;\n          node.h = 0;\n          node.closed = false;        \n        }\n        if (node.isFinish){\n          finishNode = node\n        }\n        if (!node.isStart && !node.isFinish && !node.isWall){\n          document.getElementById(`node-${node.row}-${node.col}`).className = 'node'\n        }\n\n      }\n    }\n    gridCopy[row][col].isStart = true;\n    startNode = gridCopy[row][col];\n\n    if (this.state.algoType === 'dijkstra'){\n      this.getDijkstra(gridCopy, startNode, finishNode)\n    } else if (this.state.algoType === 'dfs'){\n      this.getDfs(gridCopy, startNode, finishNode)\n    } else if (this.state.algoType === 'bfs'){\n      this.getBfs(gridCopy, startNode, finishNode)\n    } else if (this.state.algoType === 'astar'){\n      this.getAstar(gridCopy, startNode, finishNode)\n    } \n\n    // this.setState({startRow:row, startCol:col})\n    return gridCopy\n  }\n\n  getNewFinishWithAlgo = (grid, row, col) => {\n    if(grid[row][col].isWall) return;\n    const gridCopy = grid.slice();\n    let startNode = null;\n    let finishNode = null;\n    for (const rows of gridCopy){\n      for (const node of rows){\n        if (!node.isWall){\n          node.isFinish = false;\n          node.distance = Infinity;\n          node.isVisited = false;\n          node.isShortestPath = false;\n          node.previousNode = null;\n          node.g = Infinity;\n          node.f = 0;\n          node.h = 0;\n          node.closed = false;        \n        }\n        if (node.isStart){\n          startNode = node\n        }\n        if (!node.isStart && !node.isFinish && !node.isWall){\n          document.getElementById(`node-${node.row}-${node.col}`).className = 'node'\n        }\n\n      }\n    }\n    gridCopy[row][col].isFinish = true;\n    finishNode = gridCopy[row][col];\n\n    if (this.state.algoType === 'dijkstra'){\n      this.getDijkstra(gridCopy, startNode, finishNode)\n    } else if (this.state.algoType === 'dfs'){\n      this.getDfs(gridCopy, startNode, finishNode)\n    } else if (this.state.algoType === 'bfs'){\n      this.getBfs(gridCopy, startNode, finishNode)\n    } else if (this.state.algoType === 'astar'){\n      this.getAstar(gridCopy, startNode, finishNode)\n    } \n\n    // this.setState({startRow:row, startCol:col})\n    return gridCopy\n\n  }\n\n  getDijkstra = (grid, startNode, finishNode) => {\n    const start = startNode\n    const finish = finishNode\n    const updatedNodes = dijkstra(grid, start, finish);\n    getNodesInShortestPathOrderDijkstra(finish)\n    for (const node of updatedNodes){\n      if (node.isStart && node.isShortestPath){\n        document.getElementById(`node-${node.row}-${node.col}`).className = 'node node-visited-start'\n      } else if (node.isStart && !node.isShortestPath){\n        document.getElementById(`node-${node.row}-${node.col}`).className = 'node node-start-noshortestpath'\n      } else if (node.isFinish && !node.isShortestPath){\n        document.getElementById(`node-${node.row}-${node.col}`).className = 'node node-finish-noshortestpath'\n      }\n      else if (node.isFinish && node.isShortestPath){\n        document.getElementById(`node-${node.row}-${node.col}`).className = 'node node-visited-finish'\n      } else if (node.isShortestPath){\n        document.getElementById(`node-${node.row}-${node.col}`).className = 'node node-shortest-path'\n      } else if (node.isVisited && !node.isStart && !node.isFinish && !node.isShortestPath){\n        document.getElementById(`node-${node.row}-${node.col}`).className = 'node node-visited-dijkstra'\n      } else if (node.isWall){\n        document.getElementById(`node-${node.row}-${node.col}`).className = 'node node-wall'\n      }\n    }\n    if (!finish.isVisited){\n      document.getElementById(`node-${finish.row}-${finish.col}`).className = 'node node-finish-noshortestpath'\n    }\n  }\n\n  getDfs = (grid, startNode, finishNode) => {\n    const start = startNode;\n    const finish = finishNode;\n    const updatedNodes = dfs(grid, start, finish);\n    getNodesInShortestPathOrderDfs(finish)\n    for (const node of updatedNodes){\n      if (node.isStart && node.isShortestPath){\n        document.getElementById(`node-${node.row}-${node.col}`).className = 'node node-visited-start'\n      } else if (node.isStart && !node.isShortestPath){\n        document.getElementById(`node-${node.row}-${node.col}`).className = 'node node-start-noshortestpath'\n      } else if (node.isFinish & node.isShortestPath){\n        document.getElementById(`node-${node.row}-${node.col}`).className = 'node node-visited-finish'\n      } else if (node.isShortestPath){\n        document.getElementById(`node-${node.row}-${node.col}`).className = 'node node-shortest-path'\n      } else if (node.isVisited && !node.isStart && !node.isFinish && !node.isShortestPath){\n        document.getElementById(`node-${node.row}-${node.col}`).className = 'node node-visited-dfs'\n      } else if (node.isWall){\n        document.getElementById(`node-${node.row}-${node.col}`).className = 'node node-wall'\n      }\n    }\n    if (!finish.isVisited){\n      document.getElementById(`node-${finish.row}-${finish.col}`).className = 'node node-finish-noshortestpath'\n    } \n  }\n\n  getBfs = (grid, startNode, finishNode) => {\n    const start = startNode;\n    const finish = finishNode;\n    const updatedNodes = bfs(grid, start, finish);\n    getNodesInShortestPathOrderBfs(finish)\n    for (const node of updatedNodes){\n      if (node.isStart && node.isShortestPath){\n        document.getElementById(`node-${node.row}-${node.col}`).className = 'node node-visited-start'\n      } else if (node.isStart && !node.isShortestPath){\n        document.getElementById(`node-${node.row}-${node.col}`).className = 'node node-start-noshortestpath'\n      } else if (node.isFinish & node.isShortestPath){\n        document.getElementById(`node-${node.row}-${node.col}`).className = 'node node-visited-finish'\n      } else if (node.isShortestPath){\n        document.getElementById(`node-${node.row}-${node.col}`).className = 'node node-shortest-path'\n      } else if (node.isVisited && !node.isStart && !node.isFinish && !node.isShortestPath){\n        document.getElementById(`node-${node.row}-${node.col}`).className = 'node node-visited-bfs'\n      } else if (node.isWall){\n        document.getElementById(`node-${node.row}-${node.col}`).className = 'node node-wall'\n      }\n    }\n    if (!finish.isVisited){\n      document.getElementById(`node-${finish.row}-${finish.col}`).className = 'node node-finish-noshortestpath'\n    }\n  }\n\n  getAstar = (grid, startNode, finishNode) => {\n    const start = startNode;\n    const finish = finishNode;\n    const updatedNodes = astar(grid, start, finish);\n    getNodesInShortestPathOrderAstar(finish)\n    for (const node of updatedNodes){\n      if (node.isStart && node.isShortestPath){\n        document.getElementById(`node-${node.row}-${node.col}`).className = 'node node-visited-start'\n      } else if (node.isStart && !node.isShortestPath){\n        document.getElementById(`node-${node.row}-${node.col}`).className = 'node node-start-noshortestpath'\n      } else if (node.isFinish & node.isShortestPath){\n        document.getElementById(`node-${node.row}-${node.col}`).className = 'node node-visited-finish'\n      } else if (node.isShortestPath){\n        document.getElementById(`node-${node.row}-${node.col}`).className = 'node node-shortest-path'\n      } else if (node.isVisited && !node.isStart && !node.isFinish && !node.isShortestPath){\n        document.getElementById(`node-${node.row}-${node.col}`).className = 'node node-visited-astar'\n      } else if (node.isWall){\n        document.getElementById(`node-${node.row}-${node.col}`).className = 'node node-wall'\n      }\n    }\n    if (!finish.isVisited){\n      document.getElementById(`node-${finish.row}-${finish.col}`).className = 'node node-finish-noshortestpath'\n    }\n  }\n\n  handleMouseDown = (row, col) => {\n    if (row === this.state.startRow && col === this.state.startCol && !this.state.algoDone){\n      const newGridStart = this.getNewStartWithToggle(this.state.grid, row, col);\n      this.setState({grid: newGridStart, mouseIsPressed: true, start: true, end: false, wall: false});\n    } else if (row === this.state.endRow && col === this.state.endCol && !this.state.algoDone){\n      const newGridEnd = this.getNewTargetwithToggle(this.state.grid, row, col)\n      this.setState({grid:newGridEnd, mouseIsPressed: true, start: false, end: true, wall: false})\n\n      //check if i need to include this condition\n    } else if (!this.state.algoDone) {\n      // getNewGridWithWallToggled(this.state.grid, row, col)\n      // this.setState({mouseIsPressed:true, start:false, end: false, wall:true})\n      const newGridWall = getNewGridWithWallToggled(this.state.grid, row, col);\n      this.setState({grid: newGridWall, mouseIsPressed: true, start: false, end: false, wall: true});\n    } else if (this.state.grid[row][col].isStart && this.state.algoDone){\n      this.setState({mouseIsPressed: true, start:true})}\n      else if (this.state.grid[row][col].isFinish && this.state.algoDone){\n        this.setState({mouseIsPressed: true, end:true})\n      }\n  \n  }\n\n  handleMouseEnter = (row, col) => {\n    if (!this.state.mouseIsPressed) return;\n    if (this.state.start && !this.state.algoDone){\n      const newGridStart = this.getNewStartWithToggle(this.state.grid, row, col);\n      this.setState({grid:newGridStart});\n    } else if(this.state.end && !this.state.algoDone){\n      const newGridEnd = this.getNewTargetwithToggle(this.state.grid, row, col);\n      this.setState({grid: newGridEnd})\n    } else if (this.state.wall && !this.state.algoDone){\n      // getNewGridWithWallToggled(this.state.grid, row, col)\n      const newGridWall = getNewGridWithWallToggled(this.state.grid, row, col);\n      this.setState({grid: newGridWall})\n    } else if (this.state.algoDone&&this.state.start){\n      this.getNewStartWithAlgo(this.state.grid, row, col)\n    } else if (this.state.algoDone && this.state.end){\n      this.getNewFinishWithAlgo(this.state.grid, row, col)\n    }\n\n  }\n\n  handleMouseUp = () => {\n    this.setState({mouseIsPressed: false, start:false, end:false, wall:false});\n  }\n  \n  clearWalls = () => {\n    const newGrid = clearAllWalls(this.state.grid);\n    this.setState({grid: newGrid});\n  }\n  \n\n  animateDijkstra = (visitedNodesInOrder, nodesInShortestPathOrder) => {\n    for (let i = 0; i <= visitedNodesInOrder.length; i++) {\n      if (i === visitedNodesInOrder.length) {\n        setTimeout(() => {\n          this.animateShortestPath(nodesInShortestPathOrder);\n        }, 10 * i);\n        return;\n      }\n      setTimeout(() => {\n        const node = visitedNodesInOrder[i];\n        if (node.isStart){\n          document.getElementById(`node-${node.row}-${node.col}`).className = 'node node-visited-start-animate-dijkstra'\n        } else if (node.isFinish){\n          document.getElementById(`node-${node.row}-${node.col}`).className = 'node node-visited-finish-animate-dijkstra'\n        }\n        else {document.getElementById(`node-${node.row}-${node.col}`).className =\n          'node node-visited-animate-dijkstra';}\n      }, 10 * i);\n    }\n  }\n\n  animateShortestPath = (nodesInShortestPathOrder) => {\n    for (let i = 0; i < nodesInShortestPathOrder.length; i++) {\n      setTimeout(() => {\n        const node = nodesInShortestPathOrder[i];\n        if (node.isStart){\n          document.getElementById(`node-${node.row}-${node.col}`).className = 'node node-shortestPath-start-animate'\n        } else if(node.isFinish && !node.isVisited){\n          document.getElementById(`node-${node.row}-${node.col}`).className = 'node node-finish-noshortestpath'\n        }\n        else if (node.isFinish && node.isVisited){\n           document.getElementById(`node-${node.row}-${node.col}`).className = 'node node-shortestPath-finish-animate'\n        }else {document.getElementById(`node-${node.row}-${node.col}`).className =\n          'node node-shortestPath-animate';}\n      }, 50 * i);\n    }\n  }\n\n\n  animateDfs = (visitedNodesInOrder, nodesInShortestPathOrder) => {\n    for (let i = 0; i <= visitedNodesInOrder.length; i++) {\n      if (i === visitedNodesInOrder.length) {\n        setTimeout(() => {\n          this.animateShortestPath(nodesInShortestPathOrder);\n        }, 10 * i);\n        return;\n      }\n      setTimeout(() => {\n        const node = visitedNodesInOrder[i];\n        if (node.isStart){\n          document.getElementById(`node-${node.row}-${node.col}`).className = 'node node-visited-start-animate-dfs'\n        } else if (node.isFinish){\n          document.getElementById(`node-${node.row}-${node.col}`).className = 'node node-visited-finish-animate-dfs'\n        }else {document.getElementById(`node-${node.row}-${node.col}`).className =\n          'node node-visited-animate-dfs';\n        }\n      }, 10 * i);\n    }\n  }\n\n  animateBfs = (visitedNodesInOrder, nodesInShortestPathOrder) => {\n    for (let i = 0; i <= visitedNodesInOrder.length; i++) {\n      if (i === visitedNodesInOrder.length) {\n        setTimeout(() => {\n          this.animateShortestPath(nodesInShortestPathOrder);\n        }, 10 * i);\n        return;\n      }\n      setTimeout(() => {\n        const node = visitedNodesInOrder[i];\n        if (node.isStart){\n          document.getElementById(`node-${node.row}-${node.col}`).className = 'node node-visited-start-animate-bfs'\n        } else if (node.isFinish){\n          document.getElementById(`node-${node.row}-${node.col}`).className = 'node node-visited-finish-animate-bfs'\n        }else {document.getElementById(`node-${node.row}-${node.col}`).className =\n          'node node-visited-animate-bfs';\n        }\n      }, 10 * i);\n    }\n  }\n\n  animateAStar = (visitedNodesInOrder, nodesInShortestPathOrder) => {\n    for (let i = 0; i <= visitedNodesInOrder.length; i++) {\n      if (i === visitedNodesInOrder.length) {\n        setTimeout(() => {\n          this.animateShortestPath(nodesInShortestPathOrder);\n        }, 10 * i);\n        return;\n      }\n      setTimeout(() => {\n        const node = visitedNodesInOrder[i];\n        if (node.isStart){\n          document.getElementById(`node-${node.row}-${node.col}`).className = 'node node-visited-start-animate-astar'\n        } else if (node.isFinish){\n          document.getElementById(`node-${node.row}-${node.col}`).className = 'node node-visited-finish-animate-astar'\n        }else {document.getElementById(`node-${node.row}-${node.col}`).className =\n          'node node-visited-animate-astar';\n        }\n      }, 10 * i);\n    }\n  }\n\n  animateRecusiveDivMaze = (wallsToAnimate) => {\n    for (let i = 0; i < wallsToAnimate.length; i++) {\n      setTimeout(() => {\n        const node = wallsToAnimate[i];\n        document.getElementById(`node-${node.row}-${node.col}`).className =\n          'node node-wall';\n      }, 15 * i);\n    }  \n  }\n\n  visualizeRecursiveDivMaze = () => {\n    const {grid} = this.state;\n    const mazeWalls = recursiveDivisionMaze(grid, 2, 13, 2, 47,\"horizontal\", false, [])\n    this.animateRecusiveDivMaze(mazeWalls)\n  }\n\n\n\n  clearPathNewAlgo = (start, finish ,walls) => {\n    const grid = [];\n    for (let row = 0; row < 16; row++) {\n      const currentRow = [];\n      for (let col = 0; col < 50; col++) {\n        currentRow.push(this.createNodeNewAlgo(col, row, start,finish));\n       \n      }\n      grid.push(currentRow);\n    }  \n    if (walls.length > 0){\n      for (const rows of grid){\n        for (const node of rows){\n          for(const wallNode of walls){\n            if (wallNode.row === node.row && wallNode.col === node.col){\n              node.isWall = true\n            }\n          }\n        }\n      }\n    } \n    return grid ;\n  }\n    \n  createNodeNewAlgo = (col, row, start,finish) => {\n    return {\n      col,\n      row,\n      isStart: row === start.row && col === start.col,\n      isFinish: row === finish.row && col === finish.col,\n      distance: Infinity,\n      isVisited: false,\n      isShortestPath: false,\n      isWall: false,\n      previousNode: null,\n      g : Infinity,\n      f : 0,\n      h : 0,\n      closed: false\n    };\n  };\n\n  resetBoardNewAlgoDijkstra = (board) => {\n    const grid = board;\n\n    this.setState({grid:grid})\n      // start: false,\n      // wall: false,\n      // end: false})\n      // algoDone: false,\n      // algoType: ''});\n    \n    let startNode = null;\n    let finishNode = null;\n    for (const row of grid){\n      for (const node of row){\n        if (node.isStart){\n          startNode = node\n          document.getElementById(`node-${node.row}-${node.col}`).className = 'node node-start'\n        }else if (node.isFinish){\n          finishNode = node\n          document.getElementById(`node-${node.row}-${node.col}`).className = 'node node-finish'\n        }else if(node.isWall){\n          document.getElementById(`node-${node.row}-${node.col}`).className = 'node node-wall'\n        }else{\n          document.getElementById(`node-${node.row}-${node.col}`).className = 'node'\n        }\n      }\n    }\n    const dijkstraVisitedNodes = dijkstra(grid, startNode, finishNode)\n    const shortestPath = getNodesInShortestPathOrderDijkstra(finishNode)\n    this.animateDijkstra(dijkstraVisitedNodes, shortestPath)\n  \n    this.setState({algoDone:true, algoType: 'dijkstra'})\n    return grid\n  }\n  resetBoardNewAlgoDfs = (board) => {\n    const grid = board\n\n    this.setState({grid:grid})\n      // start: false,\n      // wall: false,\n      // end: false})\n      // algoDone: false,\n      // algoType: ''});\n    \n    let startNode = null;\n    let finishNode = null;\n    for (const row of grid){\n      for (const node of row){\n        if (node.isStart){\n          startNode = node\n          document.getElementById(`node-${node.row}-${node.col}`).className = 'node node-start'\n        }else if (node.isFinish){\n          finishNode = node\n          document.getElementById(`node-${node.row}-${node.col}`).className = 'node node-finish'\n        }else if (node.isWall){\n          document.getElementById(`node-${node.row}-${node.col}`).className = 'node node-wall'\n        }\n        else{\n          document.getElementById(`node-${node.row}-${node.col}`).className = 'node'\n        }\n      }\n    }\n    const dfsVisitedNodes= dfs(grid, startNode, finishNode)\n    const dfsShortestPath = getNodesInShortestPathOrderDfs(finishNode)\n    this.animateDfs(dfsVisitedNodes, dfsShortestPath)\n  \n    this.setState({algoDone:true, algoType: 'dfs'})\n    return grid\n    \n  } \n  \n\n  resetBoardNewAlgoBfs = (board) => {\n    const grid = board\n\n    this.setState({grid:grid})\n      // start: false,\n      // wall: false,\n      // end: false})\n      // algoDone: false,\n      // algoType: ''});\n    \n    let startNode = null;\n    let finishNode = null;\n    for (const row of grid){\n      for (const node of row){\n        if (node.isStart){\n          startNode = node\n          document.getElementById(`node-${node.row}-${node.col}`).className = 'node node-start'\n        }else if (node.isFinish){\n          finishNode = node\n          document.getElementById(`node-${node.row}-${node.col}`).className = 'node node-finish'\n        }else if (node.isWall){\n          document.getElementById(`node-${node.row}-${node.col}`).className = 'node node-wall'\n        }\n        else{\n          document.getElementById(`node-${node.row}-${node.col}`).className = 'node'\n        }\n      }\n    }\n    console.log(grid)\n    console.log('startNode BFS', startNode, finishNode)\n    const bfsVisitedNodes= bfs(grid, startNode, finishNode)\n    const bfsShortestPath = getNodesInShortestPathOrderBfs(finishNode)\n    console.log('bfsVisitedNodes', bfsVisitedNodes)\n    console.log('bfsshortestPath', bfsShortestPath)\n    this.animateBfs(bfsVisitedNodes, bfsShortestPath)\n  \n    this.setState({algoDone:true, algoType: 'bfs'})\n    return grid\n  } \n  resetBoardNewAlgoAstar = (board) => {\n    const grid = board\n\n    this.setState({grid:grid})\n      // start: false,\n      // wall: false,\n      // end: false})\n      // algoDone: false,\n      // algoType: ''});\n    \n    let startNode = null;\n    let finishNode = null;\n    for (const row of grid){\n      for (const node of row){\n        if (node.isStart){\n          startNode = node\n          document.getElementById(`node-${node.row}-${node.col}`).className = 'node node-start'\n        }else if (node.isFinish){\n          finishNode = node\n          document.getElementById(`node-${node.row}-${node.col}`).className = 'node node-finish'\n        }else if (node.isWall){\n          document.getElementById(`node-${node.row}-${node.col}`).className = 'node node-wall'\n        }\n        else{\n          document.getElementById(`node-${node.row}-${node.col}`).className = 'node'\n        }\n      }\n    }\n    const astarVisitedNodes= astar(grid, startNode, finishNode)\n    const astarShortestPath = getNodesInShortestPathOrderAstar(finishNode)\n    this.animateAStar(astarVisitedNodes, astarShortestPath)\n  \n    this.setState({algoDone:true, algoType: 'astar'})\n    return grid\n    \n  } \n  \n  visualizeDijkstra = () => {\n    if (this.state.algoDone){\n      this.setState({algoDone:false});\n      const newGrid= this.state.grid\n      let start = null\n      let finish = null\n      const walls = []\n      for (const rows of newGrid){\n        for (const node of rows){\n          if (node.isStart){\n            start = node\n          }\n          if (node.isFinish){\n            finish = node\n          }\n          if (node.isWall){\n            walls.push(node)\n          }\n        }\n      }\n      const newGridAlgoStart = this.clearPathNewAlgo(start, finish, walls );\n      this.resetBoardNewAlgoDijkstra(newGridAlgoStart, this.state.algoType);\n\n\n    }else{\n      const {grid} = this.state;\n      const startNode = grid[this.state.startRow][this.state.startCol];\n      const finishNode = grid[this.state.endRow][this.state.endCol];\n      const visitedNodesInOrder = dijkstra(grid, startNode, finishNode);\n      const nodesInShortestPathOrder = getNodesInShortestPathOrderDijkstra(finishNode);\n      this.animateDijkstra(visitedNodesInOrder, nodesInShortestPathOrder);\n      console.log('astar', visitedNodesInOrder)\n      this.setState({algoDone: true, algoType : 'dijkstra'})\n    } \n  }\n \n  visualizeDfs = () => {\n    if (this.state.algoDone){\n      this.setState({algoDone: false});\n      const newGrid= this.state.grid\n      let start = null;\n      let finish = null;\n      const walls = [];\n      for (const rows of newGrid){\n        for (const node of rows){\n          if (node.isStart){\n            start = node\n          }\n          if (node.isFinish){\n            finish = node\n          }\n          if(node.isWall){\n            walls.push(node)\n          }\n        }\n      }\n      const newGridAlgoStart = this.clearPathNewAlgo(start, finish, walls);\n      this.resetBoardNewAlgoDfs(newGridAlgoStart, this.state.algoType);\n    } \n    else{\n    const {grid} = this.state;\n    const startNode = grid[this.state.startRow][this.state.startCol];\n    const finishNode = grid[this.state.endRow][this.state.endCol];\n    const visitedNodesInOrder = dfs(grid, startNode, finishNode);\n    const nodesInShortestPathOrder = getNodesInShortestPathOrderDfs(finishNode);\n    this.animateDfs(visitedNodesInOrder, nodesInShortestPathOrder);\n    this.setState({algoDone: true, algoType: 'dfs'});\n    } \n  }\n\n  visualizeBfs = () => {\n    if (this.state.algoDone){\n      this.setState({algoDone: false});\n      const newGrid= this.state.grid\n      let start = null;\n      let finish = null;\n      const walls = [];\n      for (const rows of newGrid){\n        for (const node of rows){\n          if (node.isStart){\n            start = node\n          }\n          if (node.isFinish){\n            finish = node\n          }\n          if(node.isWall){\n            walls.push(node)\n          }\n        }\n      }\n      const newGridAlgoStart = this.clearPathNewAlgo(start, finish, walls);\n      this.resetBoardNewAlgoBfs(newGridAlgoStart, this.state.algoType);\n    } else{\n      const {grid} = this.state;\n      const startNode = grid[this.state.startRow][this.state.startCol];\n      const finishNode = grid[this.state.endRow][this.state.endCol];\n      const visitedNodesInOrder = bfs(grid, startNode, finishNode);\n      const nodesInShortestPathOrder = getNodesInShortestPathOrderBfs(finishNode);\n      this.animateBfs(visitedNodesInOrder, nodesInShortestPathOrder);\n      this.setState({algoDone: true, algoType: 'bfs'});\n    }\n  }\n  \n  visualizeAstar = () => {\n    if (this.state.algoDone){\n      this.setState({algoDone:false});\n      const newGrid= this.state.grid\n      let start = null\n      let finish = null\n      const walls = []\n      for (const rows of newGrid){\n        for (const node of rows){\n          if (node.isStart){\n            start = node\n          }\n          if (node.isFinish){\n            finish = node\n          }\n          if (node.isWall){\n            walls.push(node)\n          }\n        }\n      }\n      const newGridAlgoStart = this.clearPathNewAlgo(start, finish, walls );\n      this.resetBoardNewAlgoAstar(newGridAlgoStart, this.state.algoType);\n    } else{\n      const {grid} = this.state;\n      const startNode = grid[this.state.startRow][this.state.startCol];\n      const finishNode = grid[this.state.endRow][this.state.endCol];\n      const visitedNodesInOrder = astar(grid, startNode, finishNode);\n      const nodesInShortestPathOrder = getNodesInShortestPathOrderAstar(finishNode);\n      this.animateAStar(visitedNodesInOrder, nodesInShortestPathOrder);\n      this.setState({algoDone: true, algoType: 'astar'});\n    } \n  }\n\n\n  render() {\n    const {grid, mouseIsPressed} = this.state;\n    {console.log(this.state.algoDone)};\n   \n    return (\n      <div className = 'parent'>\n        <nav className = 'navbar'>\n          <div className = 'algoButtons'>\n            <button className = 'nav-item1' onClick={this.visualizeAstar}>\n              A* Search\n            </button> \n            <button className = 'nav-item2' onClick={this.visualizeDijkstra}>\n              Dijkstra's Algorithm\n            </button>\n            <button className = 'nav-item3' onClick={this.visualizeBfs}>\n              BFS Search \n            </button>\n            <button className = 'nav-item4' onClick={this.visualizeDfs}>\n              DFS Search \n            </button>\n          </div>\n          <div className = 'navbar-logo'>\n            <h1>Pathfinding Visualizer</h1>\n          </div>\n          <div className = 'otherButtons'>  \n            <button  className = 'other-button' onClick = {this.clearWalls}>\n                Clear Walls\n              </button>\n              <button className = 'other-button'  onClick = {this.visualizeRecursiveDivMaze}>\n                Create Maze\n              </button>\n              <button className = 'other-button'  onClick = {this.resetBoard} >\n                Reset Board\n              </button>\n           </div>\n           </nav>\n\n        <Carousel />\n\n        <div className=\"grid\">\n        \n          {grid.map((row, rowIdx) => {\n            return (\n              //this is not the recommended way of setting key prop \n              <div key={rowIdx}>\n                {row.map((node, nodeIdx) => {\n                  const {row, col, isFinish, isStart, isWall} = node\n                  return (\n                    <Node\n                      key={nodeIdx}\n                      col={col}\n                      isFinish={isFinish}\n                      isStart={isStart}\n                      isWall={isWall}\n                      mouseIsPressed={mouseIsPressed}\n                      onMouseDown={(row, col) => this.handleMouseDown(row, col)}\n                      onMouseEnter={(row, col) =>\n                        this.handleMouseEnter(row, col)\n                      }\n                      onMouseUp={() => this.handleMouseUp()}\n                      row={row}>\n                    </Node>\n                  )\n                })}\n              </div>\n            )\n          })}\n        </div>\n      </div>  \n    )\n  }\n}\n\n\nconst clearAllWalls = (grid) => {\n  const newGrid = grid.slice();\n  for (const row of newGrid){\n    for (const node of row){\n      if (node.isWall){\n        node.isWall = !node.isWall\n      }\n      if (document.getElementById(`node-${node.row}-${node.col}`).className === \"node node-wall\"){\n        document.getElementById(`node-${node.row}-${node.col}`).className = \"node\";\n      }\n    }\n  }\n  return newGrid;\n}\n\n\n\nconst getNewGridWithWallToggled = (grid, row, col) => {\n   const newGrid = grid.slice();\n  const node = newGrid[row][col];\n  const newNode = {\n    ...node,\n    isWall: !node.isWall,\n  };\n  newGrid[row][col] = newNode;\n  return newGrid;\n};","/Users/gilbertosanchez/pathfinder_visualizer/src/algorithms/astar.js",["39","40"],{"ruleId":"41","replacedBy":"42"},{"ruleId":"43","replacedBy":"44"},{"ruleId":"45","severity":1,"message":"46","line":825,"column":5,"nodeType":"47","messageId":"48","endLine":825,"endColumn":39},{"ruleId":"49","severity":1,"message":"50","line":107,"column":31,"nodeType":"51","messageId":"52","endLine":107,"endColumn":33},{"ruleId":"49","severity":1,"message":"53","line":113,"column":17,"nodeType":"51","messageId":"52","endLine":113,"endColumn":19},"no-native-reassign",["54"],"no-negated-in-lhs",["55"],"no-lone-blocks","Nested block is redundant.","BlockStatement","redundantNestedBlock","eqeqeq","Expected '!==' and instead saw '!='.","BinaryExpression","unexpected","Expected '===' and instead saw '=='.","no-global-assign","no-unsafe-negation"]