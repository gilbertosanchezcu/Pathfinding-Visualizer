[{"/Users/gilbertosanchez/pathfinder_visualizer/src/algorithms/dfs.js":"1","/Users/gilbertosanchez/pathfinder_visualizer/src/index.js":"2","/Users/gilbertosanchez/pathfinder_visualizer/src/PathfindingVisualizer/PathfindingVisualizer.jsx":"3","/Users/gilbertosanchez/pathfinder_visualizer/src/algorithms/bfs.js":"4","/Users/gilbertosanchez/pathfinder_visualizer/src/App.js":"5","/Users/gilbertosanchez/pathfinder_visualizer/src/PathfindingVisualizer/Node/Node.jsx":"6","/Users/gilbertosanchez/pathfinder_visualizer/src/algorithms/dijkstra.js":"7","/Users/gilbertosanchez/pathfinder_visualizer/src/reportWebVitals.js":"8","/Users/gilbertosanchez/pathfinder_visualizer/src/algorithms/astar.js":"9","/Users/gilbertosanchez/pathfinder_visualizer/src/Maze/recursiveDivMaze.js":"10","/Users/gilbertosanchez/pathfinder_visualizer/src/Notification/Slider.js":"11","/Users/gilbertosanchez/pathfinder_visualizer/src/Notification/Items.js":"12","/Users/gilbertosanchez/pathfinder_visualizer/src/Notification/Carousel.js":"13"},{"size":1929,"mtime":1613599876236,"results":"14","hashOfConfig":"15"},{"size":500,"mtime":1606768651351,"results":"16","hashOfConfig":"15"},{"size":32536,"mtime":1613761290347,"results":"17","hashOfConfig":"15"},{"size":2039,"mtime":1613599844306,"results":"18","hashOfConfig":"15"},{"size":278,"mtime":1607892759199,"results":"19","hashOfConfig":"15"},{"size":692,"mtime":1613601023766,"results":"20","hashOfConfig":"15"},{"size":2609,"mtime":1613599889701,"results":"21","hashOfConfig":"15"},{"size":362,"mtime":1606768651357,"results":"22","hashOfConfig":"15"},{"size":6864,"mtime":1613599833690,"results":"23","hashOfConfig":"15"},{"size":3480,"mtime":1613423115270,"results":"24","hashOfConfig":"15"},{"size":2968,"mtime":1613085494553,"results":"25","hashOfConfig":"15"},{"size":2540,"mtime":1613600099187,"results":"26","hashOfConfig":"15"},{"size":170,"mtime":1612468709757,"results":"27","hashOfConfig":"15"},{"filePath":"28","messages":"29","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"30"},"1b9c5ul",{"filePath":"31","messages":"32","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"33"},{"filePath":"34","messages":"35","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"36","usedDeprecatedRules":"33"},{"filePath":"37","messages":"38","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"39"},{"filePath":"40","messages":"41","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"42"},{"filePath":"43","messages":"44","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"45"},{"filePath":"46","messages":"47","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"48"},{"filePath":"49","messages":"50","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"48"},{"filePath":"51","messages":"52","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"53","usedDeprecatedRules":"33"},{"filePath":"54","messages":"55","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"33"},{"filePath":"56","messages":"57","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"58","usedDeprecatedRules":"59"},{"filePath":"60","messages":"61","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"62","messages":"63","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"48"},"/Users/gilbertosanchez/pathfinder_visualizer/src/algorithms/dfs.js",[],["64","65"],"/Users/gilbertosanchez/pathfinder_visualizer/src/index.js",[],["66","67"],"/Users/gilbertosanchez/pathfinder_visualizer/src/PathfindingVisualizer/PathfindingVisualizer.jsx",["68"],"import React, {Component} from 'react';\nimport Node from './Node/Node';\nimport {dijkstra, getNodesInShortestPathOrderDijkstra} from '../algorithms/dijkstra';\nimport {dfs, getNodesInShortestPathOrderDfs} from '../algorithms/dfs';\nimport {bfs, getNodesInShortestPathOrderBfs} from '../algorithms/bfs';\nimport {astar, getNodesInShortestPathOrderAstar} from '../algorithms/astar';\nimport {recursiveDivisionMaze} from '../Maze/recursiveDivMaze';\nimport {Carousel} from '../Notification/Carousel';\nimport '../Navbar/Navbar.css';\nimport './PathfindingVisualizer.css';\n\n// const START_ROW = 10;\n// const START_COL = 15;\n// const END_ROW = 10;\n// const END_COL = 35;\n// const objectTargetStatus = ['node node-start', 'node node-finish'];\n// const objectPathStatus = [\"node node-visited\", \"node node-shortest-path\", \"node node-wall\"]\n\nexport default class PathfindingVisualizer extends Component {\n  constructor() {\n    super();\n    this.state = {\n      grid: [],\n      mouseIsPressed: false,\n      startRow : 8,\n      startCol : 15,\n      endRow : 8,\n      endCol : 35,\n      start: false,\n      wall: false,\n      end: false,\n      algoDone: false,\n      algoType: ''\n    };\n  } \n\n\n  componentDidMount() {\n    const grid = this.getInitialGrid();\n    this.setState({grid});\n  };\n\n\n  shouldComponentUpdate(prevProps, prevState){\n    if(prevState.algoDone === false){\n      return true\n    }else {\n      return false\n    }\n  }\n  getInitialGrid = () => {\n    const grid = [];\n    for (let row = 0; row <16; row++) {\n      const currentRow = [];\n      for (let col = 0; col < 50; col++) {\n        currentRow.push(this.createNode(col, row));\n      }\n      grid.push(currentRow);\n    }  \n    return grid;\n  }\n  createNode = (col, row) => {\n    return {\n      col,\n      row,\n      isStart: row === this.state.startRow && col === this.state.startCol,\n      isFinish: row === this.state.endRow && col === this.state.endCol,\n      distance: Infinity,\n      isVisited: false,\n      isShortestPath: false,\n      isWall: false,\n      previousNode: null,\n      g : Infinity,\n      f : 0,\n      h : 0,\n      closed: false\n    };\n  };\n\n  resetBoard = () => {\n    const grid = this.getInitialGrid();\n\n    this.setState({grid:grid,\n      start: false,\n      wall: false,\n      end: false,\n      algoDone: false,\n      algoType: ''});\n\n    for (const row of grid){\n      for (const node of row){\n        if (node.isStart){\n          document.getElementById(`node-${node.row}-${node.col}`).className = 'node node-start'\n        }else if (node.isFinish){\n          document.getElementById(`node-${node.row}-${node.col}`).className = 'node node-finish'\n        }else{\n          document.getElementById(`node-${node.row}-${node.col}`).className = 'node'\n        }\n      }\n    }\n    return grid;\n  }\n\n  getNewStartWithToggle = (grid, row, col) => {\n    const newGrid = grid.slice();\n    const currStart = newGrid[this.state.startRow][this.state.startCol];\n    const newStart = newGrid[row][col];\n    if (row !== this.state.startRow || col !== this.state.startCol){\n      currStart.isStart = false;\n      newStart.isStart = true;\n      this.setState({startRow: row, startCol: col});\n    }\n\n    return newGrid;\n  }\n\n\n\n  getNewTargetwithToggle = (grid, row, col) => {\n    const newGrid = grid.slice();\n    const currEnd = newGrid[this.state.endRow][this.state.endCol];\n    const newEnd = newGrid[row][col];\n    if (row !== this.state.endRow || col !== this.state.endCol){\n      currEnd.isFinish = false;\n      newEnd.isFinish= true;\n      this.setState({endRow: row, endCol: col});\n    }\n\n    return newGrid;\n  }\n\n  getNewStartWithAlgo = (grid,row, col) => {\n    if(grid[row][col].isWall) return;\n    const gridCopy = grid.slice();\n    let startNode = null;\n    let finishNode = null;\n    for (const rows of gridCopy){\n      for (const node of rows){\n        if (!node.isWall){\n          node.isStart = false;\n          node.distance = Infinity;\n          node.isVisited = false;\n          node.isShortestPath = false;\n          node.previousNode = null;\n          node.g = Infinity;\n          node.f = 0;\n          node.h = 0;\n          node.closed = false;        \n        }\n        if (node.isFinish){\n          finishNode = node\n        }\n        if (!node.isStart && !node.isFinish && !node.isWall){\n          document.getElementById(`node-${node.row}-${node.col}`).className = 'node'\n        }\n\n      }\n    }\n    gridCopy[row][col].isStart = true;\n    startNode = gridCopy[row][col];\n\n    if (this.state.algoType === 'dijkstra'){\n      this.getDijkstra(gridCopy, startNode, finishNode)\n    } else if (this.state.algoType === 'dfs'){\n      this.getDfs(gridCopy, startNode, finishNode)\n    } else if (this.state.algoType === 'bfs'){\n      this.getBfs(gridCopy, startNode, finishNode)\n    } else if (this.state.algoType === 'astar'){\n      this.getAstar(gridCopy, startNode, finishNode)\n    } \n\n    // this.setState({startRow:row, startCol:col})\n    return gridCopy\n  }\n\n  getNewFinishWithAlgo = (grid, row, col) => {\n    if(grid[row][col].isWall) return;\n    const gridCopy = grid.slice();\n    let startNode = null;\n    let finishNode = null;\n    for (const rows of gridCopy){\n      for (const node of rows){\n        if (!node.isWall){\n          node.isFinish = false;\n          node.distance = Infinity;\n          node.isVisited = false;\n          node.isShortestPath = false;\n          node.previousNode = null;\n          node.g = Infinity;\n          node.f = 0;\n          node.h = 0;\n          node.closed = false;        \n        }\n        if (node.isStart){\n          startNode = node\n        }\n        if (!node.isStart && !node.isFinish && !node.isWall){\n          document.getElementById(`node-${node.row}-${node.col}`).className = 'node'\n        }\n\n      }\n    }\n    gridCopy[row][col].isFinish = true;\n    finishNode = gridCopy[row][col];\n\n    if (this.state.algoType === 'dijkstra'){\n      this.getDijkstra(gridCopy, startNode, finishNode)\n    } else if (this.state.algoType === 'dfs'){\n      this.getDfs(gridCopy, startNode, finishNode)\n    } else if (this.state.algoType === 'bfs'){\n      this.getBfs(gridCopy, startNode, finishNode)\n    } else if (this.state.algoType === 'astar'){\n      this.getAstar(gridCopy, startNode, finishNode)\n    } \n\n    // this.setState({startRow:row, startCol:col})\n    return gridCopy\n\n  }\n\n  getDijkstra = (grid, startNode, finishNode) => {\n    const start = startNode\n    const finish = finishNode\n    const updatedNodes = dijkstra(grid, start, finish);\n    getNodesInShortestPathOrderDijkstra(finish)\n    for (const node of updatedNodes){\n      if (node.isStart && node.isShortestPath){\n        document.getElementById(`node-${node.row}-${node.col}`).className = 'node node-visited-start'\n      } else if (node.isStart && !node.isShortestPath){\n        document.getElementById(`node-${node.row}-${node.col}`).className = 'node node-start-noshortestpath'\n      } else if (node.isFinish && !node.isShortestPath){\n        document.getElementById(`node-${node.row}-${node.col}`).className = 'node node-finish-noshortestpath'\n      }\n      else if (node.isFinish && node.isShortestPath){\n        document.getElementById(`node-${node.row}-${node.col}`).className = 'node node-visited-finish'\n      } else if (node.isShortestPath){\n        document.getElementById(`node-${node.row}-${node.col}`).className = 'node node-shortest-path'\n      } else if (node.isVisited && !node.isStart && !node.isFinish && !node.isShortestPath){\n        document.getElementById(`node-${node.row}-${node.col}`).className = 'node node-visited-dijkstra'\n      } else if (node.isWall){\n        document.getElementById(`node-${node.row}-${node.col}`).className = 'node node-wall'\n      }\n    }\n    if (!finish.isVisited){\n      document.getElementById(`node-${finish.row}-${finish.col}`).className = 'node node-finish-noshortestpath'\n    }\n  }\n\n  getDfs = (grid, startNode, finishNode) => {\n    const start = startNode;\n    const finish = finishNode;\n    const updatedNodes = dfs(grid, start, finish);\n    getNodesInShortestPathOrderDfs(finish)\n    for (const node of updatedNodes){\n      if (node.isStart && node.isShortestPath){\n        document.getElementById(`node-${node.row}-${node.col}`).className = 'node node-visited-start'\n      } else if (node.isStart && !node.isShortestPath){\n        document.getElementById(`node-${node.row}-${node.col}`).className = 'node node-start-noshortestpath'\n      } else if (node.isFinish & node.isShortestPath){\n        document.getElementById(`node-${node.row}-${node.col}`).className = 'node node-visited-finish'\n      } else if (node.isShortestPath){\n        document.getElementById(`node-${node.row}-${node.col}`).className = 'node node-shortest-path'\n      } else if (node.isVisited && !node.isStart && !node.isFinish && !node.isShortestPath){\n        document.getElementById(`node-${node.row}-${node.col}`).className = 'node node-visited-dfs'\n      } else if (node.isWall){\n        document.getElementById(`node-${node.row}-${node.col}`).className = 'node node-wall'\n      }\n    }\n    if (!finish.isVisited){\n      document.getElementById(`node-${finish.row}-${finish.col}`).className = 'node node-finish-noshortestpath'\n    } \n  }\n\n  getBfs = (grid, startNode, finishNode) => {\n    const start = startNode;\n    const finish = finishNode;\n    const updatedNodes = bfs(grid, start, finish);\n    getNodesInShortestPathOrderBfs(finish)\n    for (const node of updatedNodes){\n      if (node.isStart && node.isShortestPath){\n        document.getElementById(`node-${node.row}-${node.col}`).className = 'node node-visited-start'\n      } else if (node.isStart && !node.isShortestPath){\n        document.getElementById(`node-${node.row}-${node.col}`).className = 'node node-start-noshortestpath'\n      } else if (node.isFinish & node.isShortestPath){\n        document.getElementById(`node-${node.row}-${node.col}`).className = 'node node-visited-finish'\n      } else if (node.isShortestPath){\n        document.getElementById(`node-${node.row}-${node.col}`).className = 'node node-shortest-path'\n      } else if (node.isVisited && !node.isStart && !node.isFinish && !node.isShortestPath){\n        document.getElementById(`node-${node.row}-${node.col}`).className = 'node node-visited-bfs'\n      } else if (node.isWall){\n        document.getElementById(`node-${node.row}-${node.col}`).className = 'node node-wall'\n      }\n    }\n    if (!finish.isVisited){\n      document.getElementById(`node-${finish.row}-${finish.col}`).className = 'node node-finish-noshortestpath'\n    }\n  }\n\n  getAstar = (grid, startNode, finishNode) => {\n    const start = startNode;\n    const finish = finishNode;\n    const updatedNodes = astar(grid, start, finish);\n    getNodesInShortestPathOrderAstar(finish)\n    for (const node of updatedNodes){\n      if (node.isStart && node.isShortestPath){\n        document.getElementById(`node-${node.row}-${node.col}`).className = 'node node-visited-start'\n      } else if (node.isStart && !node.isShortestPath){\n        document.getElementById(`node-${node.row}-${node.col}`).className = 'node node-start-noshortestpath'\n      } else if (node.isFinish & node.isShortestPath){\n        document.getElementById(`node-${node.row}-${node.col}`).className = 'node node-visited-finish'\n      } else if (node.isShortestPath){\n        document.getElementById(`node-${node.row}-${node.col}`).className = 'node node-shortest-path'\n      } else if (node.isVisited && !node.isStart && !node.isFinish && !node.isShortestPath){\n        document.getElementById(`node-${node.row}-${node.col}`).className = 'node node-visited-astar'\n      } else if (node.isWall){\n        document.getElementById(`node-${node.row}-${node.col}`).className = 'node node-wall'\n      }\n    }\n    if (!finish.isVisited){\n      document.getElementById(`node-${finish.row}-${finish.col}`).className = 'node node-finish-noshortestpath'\n    }\n  }\n\n  handleMouseDown = (row, col) => {\n    if (row === this.state.startRow && col === this.state.startCol && !this.state.algoDone){\n      const newGridStart = this.getNewStartWithToggle(this.state.grid, row, col);\n      this.setState({grid: newGridStart, mouseIsPressed: true, start: true, end: false, wall: false});\n    } else if (row === this.state.endRow && col === this.state.endCol && !this.state.algoDone){\n      const newGridEnd = this.getNewTargetwithToggle(this.state.grid, row, col)\n      this.setState({grid:newGridEnd, mouseIsPressed: true, start: false, end: true, wall: false})\n\n      //check if i need to include this condition\n    } else if (!this.state.algoDone) {\n      // getNewGridWithWallToggled(this.state.grid, row, col)\n      // this.setState({mouseIsPressed:true, start:false, end: false, wall:true})\n      const newGridWall = getNewGridWithWallToggled(this.state.grid, row, col);\n      this.setState({grid: newGridWall, mouseIsPressed: true, start: false, end: false, wall: true});\n    } else if (this.state.grid[row][col].isStart && this.state.algoDone){\n      this.setState({mouseIsPressed: true, start:true})}\n      else if (this.state.grid[row][col].isFinish && this.state.algoDone){\n        this.setState({mouseIsPressed: true, end:true})\n      }\n  \n  }\n\n  handleMouseEnter = (row, col) => {\n    if (!this.state.mouseIsPressed) return;\n    if (this.state.start && !this.state.algoDone){\n      const newGridStart = this.getNewStartWithToggle(this.state.grid, row, col);\n      this.setState({grid:newGridStart});\n    } else if(this.state.end && !this.state.algoDone){\n      const newGridEnd = this.getNewTargetwithToggle(this.state.grid, row, col);\n      this.setState({grid: newGridEnd})\n    } else if (this.state.wall && !this.state.algoDone){\n      // getNewGridWithWallToggled(this.state.grid, row, col)\n      const newGridWall = getNewGridWithWallToggled(this.state.grid, row, col);\n      this.setState({grid: newGridWall})\n    } else if (this.state.algoDone&&this.state.start){\n      this.getNewStartWithAlgo(this.state.grid, row, col)\n    } else if (this.state.algoDone && this.state.end){\n      this.getNewFinishWithAlgo(this.state.grid, row, col)\n    }\n\n  }\n\n  handleMouseUp = () => {\n    this.setState({mouseIsPressed: false, start:false, end:false, wall:false});\n  }\n  \n  clearWalls = () => {\n    const newGrid = clearAllWalls(this.state.grid);\n    this.setState({grid: newGrid});\n  }\n  \n\n  animateDijkstra = (visitedNodesInOrder, nodesInShortestPathOrder) => {\n    for (let i = 0; i <= visitedNodesInOrder.length; i++) {\n      if (i === visitedNodesInOrder.length) {\n        setTimeout(() => {\n          this.animateShortestPath(nodesInShortestPathOrder);\n        }, 10 * i);\n        return;\n      }\n      setTimeout(() => {\n        const node = visitedNodesInOrder[i];\n        if (node.isStart){\n          document.getElementById(`node-${node.row}-${node.col}`).className = 'node node-visited-start-animate-dijkstra'\n        } else if (node.isFinish){\n          document.getElementById(`node-${node.row}-${node.col}`).className = 'node node-visited-finish-animate-dijkstra'\n        }\n        else {document.getElementById(`node-${node.row}-${node.col}`).className =\n          'node node-visited-animate-dijkstra';}\n      }, 10 * i);\n    }\n  }\n\n  animateShortestPath = (nodesInShortestPathOrder) => {\n    for (let i = 0; i < nodesInShortestPathOrder.length; i++) {\n      setTimeout(() => {\n        const node = nodesInShortestPathOrder[i];\n        if (node.isStart){\n          document.getElementById(`node-${node.row}-${node.col}`).className = 'node node-shortestPath-start-animate'\n        } else if(node.isFinish && !node.isVisited){\n          document.getElementById(`node-${node.row}-${node.col}`).className = 'node node-finish-noshortestpath'\n        }\n        else if (node.isFinish && node.isVisited){\n           document.getElementById(`node-${node.row}-${node.col}`).className = 'node node-shortestPath-finish-animate'\n        }else {document.getElementById(`node-${node.row}-${node.col}`).className =\n          'node node-shortestPath-animate';}\n      }, 50 * i);\n    }\n  }\n\n\n  animateDfs = (visitedNodesInOrder, nodesInShortestPathOrder) => {\n    for (let i = 0; i <= visitedNodesInOrder.length; i++) {\n      if (i === visitedNodesInOrder.length) {\n        setTimeout(() => {\n          this.animateShortestPath(nodesInShortestPathOrder);\n        }, 10 * i);\n        return;\n      }\n      setTimeout(() => {\n        const node = visitedNodesInOrder[i];\n        if (node.isStart){\n          document.getElementById(`node-${node.row}-${node.col}`).className = 'node node-visited-start-animate-dfs'\n        } else if (node.isFinish){\n          document.getElementById(`node-${node.row}-${node.col}`).className = 'node node-visited-finish-animate-dfs'\n        }else {document.getElementById(`node-${node.row}-${node.col}`).className =\n          'node node-visited-animate-dfs';\n        }\n      }, 10 * i);\n    }\n  }\n\n  animateBfs = (visitedNodesInOrder, nodesInShortestPathOrder) => {\n    for (let i = 0; i <= visitedNodesInOrder.length; i++) {\n      if (i === visitedNodesInOrder.length) {\n        setTimeout(() => {\n          this.animateShortestPath(nodesInShortestPathOrder);\n        }, 10 * i);\n        return;\n      }\n      setTimeout(() => {\n        const node = visitedNodesInOrder[i];\n        if (node.isStart){\n          document.getElementById(`node-${node.row}-${node.col}`).className = 'node node-visited-start-animate-bfs'\n        } else if (node.isFinish){\n          document.getElementById(`node-${node.row}-${node.col}`).className = 'node node-visited-finish-animate-bfs'\n        }else {document.getElementById(`node-${node.row}-${node.col}`).className =\n          'node node-visited-animate-bfs';\n        }\n      }, 10 * i);\n    }\n  }\n\n  animateAStar = (visitedNodesInOrder, nodesInShortestPathOrder) => {\n    for (let i = 0; i <= visitedNodesInOrder.length; i++) {\n      if (i === visitedNodesInOrder.length) {\n        setTimeout(() => {\n          this.animateShortestPath(nodesInShortestPathOrder);\n        }, 10 * i);\n        return;\n      }\n      setTimeout(() => {\n        const node = visitedNodesInOrder[i];\n        if (node.isStart){\n          document.getElementById(`node-${node.row}-${node.col}`).className = 'node node-visited-start-animate-astar'\n        } else if (node.isFinish){\n          document.getElementById(`node-${node.row}-${node.col}`).className = 'node node-visited-finish-animate-astar'\n        }else {document.getElementById(`node-${node.row}-${node.col}`).className =\n          'node node-visited-animate-astar';\n        }\n      }, 10 * i);\n    }\n  }\n\n  animateRecusiveDivMaze = (wallsToAnimate) => {\n    for (let i = 0; i < wallsToAnimate.length; i++) {\n      setTimeout(() => {\n        const node = wallsToAnimate[i];\n        document.getElementById(`node-${node.row}-${node.col}`).className =\n          'node node-wall';\n      }, 15 * i);\n    }  \n  }\n\n  visualizeRecursiveDivMaze = () => {\n    const {grid} = this.state;\n    const mazeWalls = recursiveDivisionMaze(grid, 2, 13, 2, 47,\"horizontal\", false, [])\n    this.animateRecusiveDivMaze(mazeWalls)\n  }\n\n\n\n  clearPathNewAlgo = (start, finish ,walls) => {\n    const grid = [];\n    for (let row = 0; row < 16; row++) {\n      const currentRow = [];\n      for (let col = 0; col < 50; col++) {\n        currentRow.push(this.createNodeNewAlgo(col, row, start,finish));\n       \n      }\n      grid.push(currentRow);\n    }  \n    if (walls.length > 0){\n      for (const rows of grid){\n        for (const node of rows){\n          for(const wallNode of walls){\n            if (wallNode.row === node.row && wallNode.col === node.col){\n              node.isWall = true\n            }\n          }\n        }\n      }\n    } \n    return grid ;\n  }\n    \n  createNodeNewAlgo = (col, row, start,finish) => {\n    return {\n      col,\n      row,\n      isStart: row === start.row && col === start.col,\n      isFinish: row === finish.row && col === finish.col,\n      distance: Infinity,\n      isVisited: false,\n      isShortestPath: false,\n      isWall: false,\n      previousNode: null,\n      g : Infinity,\n      f : 0,\n      h : 0,\n      closed: false\n    };\n  };\n\n  resetBoardNewAlgoDijkstra = (board) => {\n    const grid = board;\n\n    this.setState({grid:grid})\n      // start: false,\n      // wall: false,\n      // end: false})\n      // algoDone: false,\n      // algoType: ''});\n    \n    let startNode = null;\n    let finishNode = null;\n    for (const row of grid){\n      for (const node of row){\n        if (node.isStart){\n          startNode = node\n          document.getElementById(`node-${node.row}-${node.col}`).className = 'node node-start'\n        }else if (node.isFinish){\n          finishNode = node\n          document.getElementById(`node-${node.row}-${node.col}`).className = 'node node-finish'\n        }else if(node.isWall){\n          document.getElementById(`node-${node.row}-${node.col}`).className = 'node node-wall'\n        }else{\n          document.getElementById(`node-${node.row}-${node.col}`).className = 'node'\n        }\n      }\n    }\n    const dijkstraVisitedNodes = dijkstra(grid, startNode, finishNode)\n    const shortestPath = getNodesInShortestPathOrderDijkstra(finishNode)\n    this.animateDijkstra(dijkstraVisitedNodes, shortestPath)\n  \n    this.setState({algoDone:true, algoType: 'dijkstra'})\n    return grid\n  }\n  resetBoardNewAlgoDfs = (board) => {\n    const grid = board\n\n    this.setState({grid:grid})\n      // start: false,\n      // wall: false,\n      // end: false})\n      // algoDone: false,\n      // algoType: ''});\n    \n    let startNode = null;\n    let finishNode = null;\n    for (const row of grid){\n      for (const node of row){\n        if (node.isStart){\n          startNode = node\n          document.getElementById(`node-${node.row}-${node.col}`).className = 'node node-start'\n        }else if (node.isFinish){\n          finishNode = node\n          document.getElementById(`node-${node.row}-${node.col}`).className = 'node node-finish'\n        }else if (node.isWall){\n          document.getElementById(`node-${node.row}-${node.col}`).className = 'node node-wall'\n        }\n        else{\n          document.getElementById(`node-${node.row}-${node.col}`).className = 'node'\n        }\n      }\n    }\n    const dfsVisitedNodes= dfs(grid, startNode, finishNode)\n    const dfsShortestPath = getNodesInShortestPathOrderDfs(finishNode)\n    this.animateDfs(dfsVisitedNodes, dfsShortestPath)\n  \n    this.setState({algoDone:true, algoType: 'dfs'})\n    return grid\n    \n  } \n  \n\n  resetBoardNewAlgoBfs = (board) => {\n    const grid = board\n\n    this.setState({grid:grid})\n      // start: false,\n      // wall: false,\n      // end: false})\n      // algoDone: false,\n      // algoType: ''});\n    \n    let startNode = null;\n    let finishNode = null;\n    for (const row of grid){\n      for (const node of row){\n        if (node.isStart){\n          startNode = node\n          document.getElementById(`node-${node.row}-${node.col}`).className = 'node node-start'\n        }else if (node.isFinish){\n          finishNode = node\n          document.getElementById(`node-${node.row}-${node.col}`).className = 'node node-finish'\n        }else if (node.isWall){\n          document.getElementById(`node-${node.row}-${node.col}`).className = 'node node-wall'\n        }\n        else{\n          document.getElementById(`node-${node.row}-${node.col}`).className = 'node'\n        }\n      }\n    }\n    console.log(grid)\n    console.log('startNode BFS', startNode, finishNode)\n    const bfsVisitedNodes= bfs(grid, startNode, finishNode)\n    const bfsShortestPath = getNodesInShortestPathOrderBfs(finishNode)\n    console.log('bfsVisitedNodes', bfsVisitedNodes)\n    console.log('bfsshortestPath', bfsShortestPath)\n    this.animateBfs(bfsVisitedNodes, bfsShortestPath)\n  \n    this.setState({algoDone:true, algoType: 'bfs'})\n    return grid\n  } \n  resetBoardNewAlgoAstar = (board) => {\n    const grid = board\n\n    this.setState({grid:grid})\n      // start: false,\n      // wall: false,\n      // end: false})\n      // algoDone: false,\n      // algoType: ''});\n    \n    let startNode = null;\n    let finishNode = null;\n    for (const row of grid){\n      for (const node of row){\n        if (node.isStart){\n          startNode = node\n          document.getElementById(`node-${node.row}-${node.col}`).className = 'node node-start'\n        }else if (node.isFinish){\n          finishNode = node\n          document.getElementById(`node-${node.row}-${node.col}`).className = 'node node-finish'\n        }else if (node.isWall){\n          document.getElementById(`node-${node.row}-${node.col}`).className = 'node node-wall'\n        }\n        else{\n          document.getElementById(`node-${node.row}-${node.col}`).className = 'node'\n        }\n      }\n    }\n    const astarVisitedNodes= astar(grid, startNode, finishNode)\n    const astarShortestPath = getNodesInShortestPathOrderAstar(finishNode)\n    this.animateAStar(astarVisitedNodes, astarShortestPath)\n  \n    this.setState({algoDone:true, algoType: 'astar'})\n    return grid\n    \n  } \n  \n  visualizeDijkstra = () => {\n    if (this.state.algoDone){\n      this.setState({algoDone:false});\n      const newGrid= this.state.grid\n      let start = null\n      let finish = null\n      const walls = []\n      for (const rows of newGrid){\n        for (const node of rows){\n          if (node.isStart){\n            start = node\n          }\n          if (node.isFinish){\n            finish = node\n          }\n          if (node.isWall){\n            walls.push(node)\n          }\n        }\n      }\n      const newGridAlgoStart = this.clearPathNewAlgo(start, finish, walls );\n      this.resetBoardNewAlgoDijkstra(newGridAlgoStart, this.state.algoType);\n\n\n    }else{\n      const {grid} = this.state;\n      const startNode = grid[this.state.startRow][this.state.startCol];\n      const finishNode = grid[this.state.endRow][this.state.endCol];\n      const visitedNodesInOrder = dijkstra(grid, startNode, finishNode);\n      const nodesInShortestPathOrder = getNodesInShortestPathOrderDijkstra(finishNode);\n      this.animateDijkstra(visitedNodesInOrder, nodesInShortestPathOrder);\n      console.log('astar', visitedNodesInOrder)\n      this.setState({algoDone: true, algoType : 'dijkstra'})\n    } \n  }\n \n  visualizeDfs = () => {\n    if (this.state.algoDone){\n      this.setState({algoDone: false});\n      const newGrid= this.state.grid\n      let start = null;\n      let finish = null;\n      const walls = [];\n      for (const rows of newGrid){\n        for (const node of rows){\n          if (node.isStart){\n            start = node\n          }\n          if (node.isFinish){\n            finish = node\n          }\n          if(node.isWall){\n            walls.push(node)\n          }\n        }\n      }\n      const newGridAlgoStart = this.clearPathNewAlgo(start, finish, walls);\n      this.resetBoardNewAlgoDfs(newGridAlgoStart, this.state.algoType);\n    } \n    else{\n    const {grid} = this.state;\n    const startNode = grid[this.state.startRow][this.state.startCol];\n    const finishNode = grid[this.state.endRow][this.state.endCol];\n    const visitedNodesInOrder = dfs(grid, startNode, finishNode);\n    const nodesInShortestPathOrder = getNodesInShortestPathOrderDfs(finishNode);\n    this.animateDfs(visitedNodesInOrder, nodesInShortestPathOrder);\n    this.setState({algoDone: true, algoType: 'dfs'});\n    } \n  }\n\n  visualizeBfs = () => {\n    if (this.state.algoDone){\n      this.setState({algoDone: false});\n      const newGrid= this.state.grid\n      let start = null;\n      let finish = null;\n      const walls = [];\n      for (const rows of newGrid){\n        for (const node of rows){\n          if (node.isStart){\n            start = node\n          }\n          if (node.isFinish){\n            finish = node\n          }\n          if(node.isWall){\n            walls.push(node)\n          }\n        }\n      }\n      const newGridAlgoStart = this.clearPathNewAlgo(start, finish, walls);\n      this.resetBoardNewAlgoBfs(newGridAlgoStart, this.state.algoType);\n    } else{\n      const {grid} = this.state;\n      const startNode = grid[this.state.startRow][this.state.startCol];\n      const finishNode = grid[this.state.endRow][this.state.endCol];\n      const visitedNodesInOrder = bfs(grid, startNode, finishNode);\n      const nodesInShortestPathOrder = getNodesInShortestPathOrderBfs(finishNode);\n      this.animateBfs(visitedNodesInOrder, nodesInShortestPathOrder);\n      this.setState({algoDone: true, algoType: 'bfs'});\n    }\n  }\n  \n  visualizeAstar = () => {\n    if (this.state.algoDone){\n      this.setState({algoDone:false});\n      const newGrid= this.state.grid\n      let start = null\n      let finish = null\n      const walls = []\n      for (const rows of newGrid){\n        for (const node of rows){\n          if (node.isStart){\n            start = node\n          }\n          if (node.isFinish){\n            finish = node\n          }\n          if (node.isWall){\n            walls.push(node)\n          }\n        }\n      }\n      const newGridAlgoStart = this.clearPathNewAlgo(start, finish, walls );\n      this.resetBoardNewAlgoAstar(newGridAlgoStart, this.state.algoType);\n    } else{\n      const {grid} = this.state;\n      const startNode = grid[this.state.startRow][this.state.startCol];\n      const finishNode = grid[this.state.endRow][this.state.endCol];\n      const visitedNodesInOrder = astar(grid, startNode, finishNode);\n      const nodesInShortestPathOrder = getNodesInShortestPathOrderAstar(finishNode);\n      this.animateAStar(visitedNodesInOrder, nodesInShortestPathOrder);\n      this.setState({algoDone: true, algoType: 'astar'});\n    } \n  }\n\n\n  render() {\n    const {grid, mouseIsPressed} = this.state;\n    {console.log(this.state.algoDone)};\n   \n    return (\n      <div className = 'parent'>\n        <nav className = 'navbar'>\n          <div className = 'algoButtons'>\n            <button className = 'nav-item1' onClick={this.visualizeAstar}>\n              A* Search\n            </button> \n            <button className = 'nav-item2' onClick={this.visualizeDijkstra}>\n              Dijkstra's Algorithm\n            </button>\n            <button className = 'nav-item3' onClick={this.visualizeBfs}>\n              BFS Search \n            </button>\n            <button className = 'nav-item4' onClick={this.visualizeDfs}>\n              DFS Search \n            </button>\n          </div>\n          <div className = 'navbar-logo'>\n            <h1>Pathfinding Visualizer</h1>\n          </div>\n          <div className = 'otherButtons'>  \n            <button  className = 'other-button' onClick = {this.clearWalls}>\n                Clear Walls\n              </button>\n              <button className = 'other-button'  onClick = {this.visualizeRecursiveDivMaze}>\n                Create Maze\n              </button>\n              <button className = 'other-button'  onClick = {this.resetBoard} >\n                Reset Board\n              </button>\n           </div>\n           </nav>\n\n        <Carousel />\n\n        <div className=\"grid\">\n        \n          {grid.map((row, rowIdx) => {\n            return (\n              //this is not the recommended way of setting key prop \n              <div key={rowIdx}>\n                {row.map((node, nodeIdx) => {\n                  const {row, col, isFinish, isStart, isWall} = node\n                  return (\n                    <Node\n                      key={nodeIdx}\n                      col={col}\n                      isFinish={isFinish}\n                      isStart={isStart}\n                      isWall={isWall}\n                      mouseIsPressed={mouseIsPressed}\n                      onMouseDown={(row, col) => this.handleMouseDown(row, col)}\n                      onMouseEnter={(row, col) =>\n                        this.handleMouseEnter(row, col)\n                      }\n                      onMouseUp={() => this.handleMouseUp()}\n                      row={row}>\n                    </Node>\n                  )\n                })}\n              </div>\n            )\n          })}\n        </div>\n      </div>  \n    )\n  }\n}\n\n\nconst clearAllWalls = (grid) => {\n  const newGrid = grid.slice();\n  for (const row of newGrid){\n    for (const node of row){\n      if (node.isWall){\n        node.isWall = !node.isWall\n      }\n      if (document.getElementById(`node-${node.row}-${node.col}`).className === \"node node-wall\"){\n        document.getElementById(`node-${node.row}-${node.col}`).className = \"node\";\n      }\n    }\n  }\n  return newGrid;\n}\n\n\n\nconst getNewGridWithWallToggled = (grid, row, col) => {\n   const newGrid = grid.slice();\n  const node = newGrid[row][col];\n  const newNode = {\n    ...node,\n    isWall: !node.isWall,\n  };\n  newGrid[row][col] = newNode;\n  return newGrid;\n};","/Users/gilbertosanchez/pathfinder_visualizer/src/algorithms/bfs.js",[],["69","70"],"/Users/gilbertosanchez/pathfinder_visualizer/src/App.js",[],["71","72"],"/Users/gilbertosanchez/pathfinder_visualizer/src/PathfindingVisualizer/Node/Node.jsx",[],["73","74"],"/Users/gilbertosanchez/pathfinder_visualizer/src/algorithms/dijkstra.js",[],["75","76"],"/Users/gilbertosanchez/pathfinder_visualizer/src/reportWebVitals.js",[],"/Users/gilbertosanchez/pathfinder_visualizer/src/algorithms/astar.js",["77","78"],"//astar algo\n//need to add the (g,f,h) properties to each node \n//g - cost of path\n//h - distance from current node to end node\n//f - g+h\n\nexport function astar(grid, startNode, finishNode) {\n    const visitedNodes = [];\n    startNode.h = heuristicManhattan(startNode, finishNode)\n    startNode.g = 0\n\n    let openHeap = new BinaryHeap(function (node) {return node.f});\n    openHeap.push(startNode)\n    while (!!openHeap.content.length){\n      //use heap to get the node with the lowest cost\n      const currentNode = openHeap.pop();\n      currentNode.closed = true\n      visitedNodes.push(currentNode)\n      if (currentNode === finishNode) return visitedNodes\n      \n      openHeap = updateUnvisitedNeighbors(currentNode, grid, finishNode, openHeap)\n\n    }\n    return visitedNodes;\n}\n\n\n\n    function heuristicManhattan(pos0, pos1) {\n        const d1 = Math.abs(pos1.row - pos0.row);\n        const d2 = Math.abs(pos1.col - pos0.col);\n        return d1 + d2;\n      }\n\n    function updateUnvisitedNeighbors(node, grid, end, heap) {\n      const unvisitedNeighbors = getUnvisitedNeighbors(node, grid);\n      for (const neighbor of unvisitedNeighbors) {\n        if (neighbor.closed || neighbor.isWall) continue;\n        let newGScore = node.g + 1\n        const beenVisited = neighbor.isVisited\n        if (neighbor.isVisited === false || newGScore<neighbor.g){\n          neighbor.isVisited = true\n          neighbor.g = newGScore\n          neighbor.previousNode = node;\n          neighbor.h = heuristicManhattan(neighbor, end);\n          neighbor.f = neighbor.g + neighbor.h\n\n          if (!beenVisited){\n            heap.push(neighbor);\n          }else {\n            heap.rescoreElement(neighbor);\n          }\n        }\n\n      }\n\n      return heap;\n    }\n    \n    function getUnvisitedNeighbors(node, grid) {\n      const neighbors = [];\n      const {col, row} = node;\n      //push node above current cell\n      if (row > 0) neighbors.push(grid[row - 1][col]);\n      //push node below current cell \n      if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\n      //push node to the left of current cell \n      if (col > 0) neighbors.push(grid[row][col - 1]);\n      //push node to the right of current cell\n      if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\n      return neighbors; \n    }\n\n\n    function BinaryHeap(scoreFunction){\n      this.content = [];\n      this.scoreFunction = scoreFunction;\n    }\n    \n    BinaryHeap.prototype = {\n      push: function(element) {\n        // Add the new element to the end of the array.\n        this.content.push(element);\n        // Allow it to bubble up.\n        this.bubbleUp(this.content.length - 1);\n      },\n    \n      pop: function() {\n        // Store the first element so we can return it later.\n        var result = this.content[0];\n        // Get the element at the end of the array.\n        var end = this.content.pop();\n        // If there are any elements left, put the end element at the\n        // start, and let it sink down.\n        if (this.content.length > 0) {\n          this.content[0] = end;\n          this.sinkDown(0);\n        }\n        return result;\n      },\n    \n      remove: function(node) {\n        var length = this.content.length;\n        // To remove a value, we must search through the array to find\n        // it.\n        for (var i = 0; i < length; i++) {\n          if (this.content[i] != node) continue;\n          // When it is found, the process seen in 'pop' is repeated\n          // to fill up the hole.\n          var end = this.content.pop();\n          // If the element we popped was the one we needed to remove,\n          // we're done.\n          if (i == length - 1) break;\n          // Otherwise, we replace the removed element with the popped\n          // one, and allow it to float up or sink down as appropriate.\n          this.content[i] = end;\n          this.bubbleUp(i);\n          this.sinkDown(i);\n          break;\n        }\n      },\n    \n      size: function() {\n        return this.content.length;\n      },\n\n      rescoreElement: function(node) {\n        this.sinkDown(this.content.indexOf(node));\n      },\n\n      bubbleUp: function(n) {\n        // Fetch the element that has to be moved.\n        var element = this.content[n], score = this.scoreFunction(element);\n        // When at 0, an element can not go up any further.\n        while (n > 0) {\n          // Compute the parent element's index, and fetch it.\n          var parentN = Math.floor((n + 1) / 2) - 1,\n          parent = this.content[parentN];\n          // If the parent has a lesser score, things are in order and we\n          // are done.\n          if (score > this.scoreFunction(parent))\n            break;\n    \n          // Otherwise, swap the parent with the current element and\n          // continue.\n          this.content[parentN] = element;\n          this.content[n] = parent;\n          n = parentN;\n        }\n      },\n    \n      sinkDown: function(n) {\n        // Look up the target element and its score.\n        var length = this.content.length,\n        element = this.content[n],\n        elemScore = this.scoreFunction(element);\n    \n        while(true) {\n          // Compute the indices of the child elements.\n          var child2N = (n + 1) * 2, child1N = child2N - 1;\n          // This is used to store the new position of the element,\n          // if any.\n          var swap = null;\n          // If the first child exists (is inside the array)...\n          if (child1N < length) {\n            // Look it up and compute its score.\n            var child1 = this.content[child1N],\n            child1Score = this.scoreFunction(child1);\n            // If the score is less than our element's, we need to swap.\n            if (child1Score < elemScore)\n              swap = child1N;\n          }\n          // Do the same checks for the other child.\n          if (child2N < length) {\n            var child2 = this.content[child2N],\n            child2Score = this.scoreFunction(child2);\n            if (child2Score < (swap == null ? elemScore : child1Score))\n              swap = child2N;\n          }\n    \n          // No need to swap further, we are done.\n          if (swap == null) break;\n    \n          // Otherwise, swap and continue.\n          this.content[n] = this.content[swap];\n          this.content[swap] = element;\n          n = swap;\n        }\n      }\n    }\n    \n  // Backtracks from the finishNode to find the shortest path.\n  export function getNodesInShortestPathOrderAstar(finishNode) {\n    const nodesInShortestPathOrder = [];\n    let currentNode = finishNode;\n    while (currentNode !== null) {\n      nodesInShortestPathOrder.unshift(currentNode);\n      currentNode.isShortestPath = true;\n      currentNode = currentNode.previousNode;\n    }\n    console.log('nodesInShortestPathOrder', nodesInShortestPathOrder);\n    return nodesInShortestPathOrder;\n  }\n\n","/Users/gilbertosanchez/pathfinder_visualizer/src/Maze/recursiveDivMaze.js",[],"/Users/gilbertosanchez/pathfinder_visualizer/src/Notification/Slider.js",["79"],"import React, {useState} from 'react'\nimport './Notification.css';\nimport {CgArrowLeftO, CgArrowRightO} from 'react-icons/cg';\nimport {SliderData} from './Items';\n\n\n\nexport const Slider = ({slides}) => {\n    const [current, setCurrent] = useState([0])\n    const length = slides.length;\n\n    const nextSlide = () => {\n        if(current[0] === 0){\n            setCurrent([1,2,3,4])\n        } else if (current[0]=== 1){\n            setCurrent([5,6,7,8])\n        } else if (current[0] === 5){\n            setCurrent([9,10,11,12])\n        } else if (current[0]=== 9){\n            setCurrent([0])\n        }\n    } \n\n    const prevSlide = () => {\n        if (current[0] === 0){\n            setCurrent([9,10,11,12])\n        } else if (current[0]=== 9){\n            setCurrent([5,6,7,8])\n        } else if (current[0]=== 5){\n            setCurrent([1,2,3,4])\n        } else if (current[0] === 1){\n            setCurrent([0])\n        }\n    }\n    \n\n    if (!Array.isArray(slides)|| slides.length <= 0 ){\n        return null;\n    }\n\n    return (\n        <section className = 'notification-wrapper'>\n            <CgArrowLeftO className = 'left-arrow' onClick = {prevSlide} />\n            <CgArrowRightO className = 'right-arrow' onClick = {nextSlide}/>\n            {SliderData.map((item,index) => {\n                return (\n                    <div key = {item.id} className = {current.includes(index)? 'slide active': 'slide'}>\n                        {current.includes(index) && (\n                        <div className = {item.class}>\n                            <p> {item.text}</p>\n                        </div>)}\n                    </div>\n                )\n            })}\n\n        </section>\n    )\n        \n} \n        \n\n\n\n\n\n\n\n\n\n\n\n// function NotificationItem(props){\n//     return (\n//         <div className = 'notification-item'>\n//             <p>\n//                 {props.message}\n//             </p>\n//         </div>\n//     )\n// }\n\n// function HomeNotifications(props){\n//     return (\n//         <>\n//             <NotificationItem message = 'Click on cells to add walls' />\n//             <NotificationItem message = 'Drag Mouse and Cheese to fix start and end points' />\n//             <NotificationItem message = 'Pick an algorithm!' />\n//         </>\n//     )\n// }\n\n// function UpdatedNotifications(){\n//     return (\n//         <>\n//             <NotificationItem message = 'Drag start and endpoints to find new paths' />\n//             <NotificationItem message = 'Click on different algorithms to compare paths' />\n//             <NotificationItem message = 'Reset board to add walls' />\n//         </>\n//     )\n// }\n\n// export function Notification(props){ \n//     console.log('this is props.algoDone', props.algoDone)\n//     return (\n//         <div className='notification-wrapper'>\n//             {props.algoDone\n//                 ? <UpdatedNotifications />\n//                 : <HomeNotifications />\n//             }    \n//         </div>\n//     )\n// }",["80","81"],"/Users/gilbertosanchez/pathfinder_visualizer/src/Notification/Items.js",[],"/Users/gilbertosanchez/pathfinder_visualizer/src/Notification/Carousel.js",[],{"ruleId":"82","replacedBy":"83"},{"ruleId":"84","replacedBy":"85"},{"ruleId":"82","replacedBy":"86"},{"ruleId":"84","replacedBy":"87"},{"ruleId":"88","severity":1,"message":"89","line":825,"column":5,"nodeType":"90","messageId":"91","endLine":825,"endColumn":39},{"ruleId":"82","replacedBy":"92"},{"ruleId":"84","replacedBy":"93"},{"ruleId":"82","replacedBy":"94"},{"ruleId":"84","replacedBy":"95"},{"ruleId":"82","replacedBy":"96"},{"ruleId":"84","replacedBy":"97"},{"ruleId":"82","replacedBy":"98"},{"ruleId":"84","replacedBy":"99"},{"ruleId":"100","severity":1,"message":"101","line":107,"column":31,"nodeType":"102","messageId":"103","endLine":107,"endColumn":33},{"ruleId":"100","severity":1,"message":"104","line":113,"column":17,"nodeType":"102","messageId":"103","endLine":113,"endColumn":19},{"ruleId":"105","severity":1,"message":"106","line":10,"column":11,"nodeType":"107","messageId":"108","endLine":10,"endColumn":17},{"ruleId":"82","replacedBy":"109"},{"ruleId":"84","replacedBy":"110"},"no-native-reassign",["111"],"no-negated-in-lhs",["112"],["111"],["112"],"no-lone-blocks","Nested block is redundant.","BlockStatement","redundantNestedBlock",["111"],["112"],["111"],["112"],["111"],["112"],["111"],["112"],"eqeqeq","Expected '!==' and instead saw '!='.","BinaryExpression","unexpected","Expected '===' and instead saw '=='.","no-unused-vars","'length' is assigned a value but never used.","Identifier","unusedVar",["111"],["112"],"no-global-assign","no-unsafe-negation"]