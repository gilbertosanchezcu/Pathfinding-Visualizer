[{"/Users/gilbertosanchez/pathfinder_visualizer/src/App.js":"1","/Users/gilbertosanchez/pathfinder_visualizer/src/algorithms/dijkstra.js":"2","/Users/gilbertosanchez/pathfinder_visualizer/src/algorithms/bfs.js":"3","/Users/gilbertosanchez/pathfinder_visualizer/src/Notification/Carousel.js":"4","/Users/gilbertosanchez/pathfinder_visualizer/src/Notification/Items.js":"5","/Users/gilbertosanchez/pathfinder_visualizer/src/Notification/Slider.js":"6","/Users/gilbertosanchez/pathfinder_visualizer/src/PathfindingVisualizer/PathfindingVisualizer.jsx":"7","/Users/gilbertosanchez/pathfinder_visualizer/src/algorithms/astar.js":"8","/Users/gilbertosanchez/pathfinder_visualizer/src/reportWebVitals.js":"9","/Users/gilbertosanchez/pathfinder_visualizer/src/Maze/recursiveDivMaze.js":"10","/Users/gilbertosanchez/pathfinder_visualizer/src/PathfindingVisualizer/Node/Node.jsx":"11","/Users/gilbertosanchez/pathfinder_visualizer/src/algorithms/dfs.js":"12","/Users/gilbertosanchez/pathfinder_visualizer/src/index.js":"13","/Users/gilbertosanchez/pathfinder_visualizer/src/Notepad/MessageForm.js":"14","/Users/gilbertosanchez/pathfinder_visualizer/src/Notepad/MessageBoard.js":"15"},{"size":278,"mtime":1607892759199,"results":"16","hashOfConfig":"17"},{"size":6368,"mtime":1614457970446,"results":"18","hashOfConfig":"17"},{"size":2039,"mtime":1613599844306,"results":"19","hashOfConfig":"17"},{"size":170,"mtime":1612468709757,"results":"20","hashOfConfig":"17"},{"size":3217,"mtime":1614549876416,"results":"21","hashOfConfig":"17"},{"size":1821,"mtime":1614481025431,"results":"22","hashOfConfig":"17"},{"size":38512,"mtime":1627280807397,"results":"23","hashOfConfig":"17"},{"size":6807,"mtime":1614480920159,"results":"24","hashOfConfig":"17"},{"size":362,"mtime":1606768651357,"results":"25","hashOfConfig":"17"},{"size":3480,"mtime":1613423115270,"results":"26","hashOfConfig":"17"},{"size":741,"mtime":1614461686750,"results":"27","hashOfConfig":"17"},{"size":1832,"mtime":1614480968125,"results":"28","hashOfConfig":"17"},{"size":500,"mtime":1606768651351,"results":"29","hashOfConfig":"17"},{"size":1827,"mtime":1627280227027,"results":"30","hashOfConfig":"17"},{"size":500,"mtime":1627167256752,"results":"31","hashOfConfig":"17"},{"filePath":"32","messages":"33","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"34"},"1b9c5ul",{"filePath":"35","messages":"36","errorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"37","usedDeprecatedRules":"34"},{"filePath":"38","messages":"39","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"40"},{"filePath":"41","messages":"42","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"43"},{"filePath":"44","messages":"45","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"40"},{"filePath":"46","messages":"47","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"48"},{"filePath":"49","messages":"50","errorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"51","messages":"52","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"53","usedDeprecatedRules":"54"},{"filePath":"55","messages":"56","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"57"},{"filePath":"58","messages":"59","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"60"},{"filePath":"61","messages":"62","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"63"},{"filePath":"64","messages":"65","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"48"},{"filePath":"66","messages":"67","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"68"},{"filePath":"69","messages":"70","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"71","messages":"72","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"/Users/gilbertosanchez/pathfinder_visualizer/src/App.js",[],["73","74"],"/Users/gilbertosanchez/pathfinder_visualizer/src/algorithms/dijkstra.js",["75","76","77"],"//Dijkstra's Algorithm \n\nexport function dijkstra(grid, startNode, finishNode) {\n    const visitedNodesInOrder = [];\n    startNode.distance = 0;\n    let minHeap = new BinaryHeap(function (node) {return node.distance})\n    //const unvisitedNodes = getAllNodes(grid,startNode);\n    minHeap.push(startNode)\n    while (!!minHeap.content.length) {\n      const currentNode = minHeap.pop();\n      currentNode.closed = true\n      visitedNodesInOrder.push(currentNode)\n      if (currentNode === finishNode) return visitedNodesInOrder\n      \n      minHeap = updateUnvisitedNeighbors(currentNode, grid, minHeap)\n    } \n    return visitedNodesInOrder\n \n  }\n  \n\n  \n  function updateUnvisitedNeighbors(node, grid, heap) {\n    const unvisitedNeighbors = getUnvisitedNeighbors(node, grid);\n    for (const neighbor of unvisitedNeighbors) {\n      if (neighbor.closed || neighbor.isWall) continue;\n      let newDistance = node.distance + neighbor.weight\n      const beenVisited = neighbor.isVisited\n      if (neighbor.isVisited === false || newDistance<=neighbor.distance){\n        neighbor.isVisited = true;\n        neighbor.distance = newDistance;\n        neighbor.previousNode = node;\n\n        if (!beenVisited){\n          heap.push(neighbor);\n        }else {\n          heap.rescoreElement(neighbor);\n        }\n      }\n\n    }\n    return heap;\n  }\n    \n\n  \n  function getUnvisitedNeighbors(node, grid) {\n    const neighbors = [];\n    const {col, row} = node;\n    //push node above current cell\n    if (row > 0) neighbors.push(grid[row - 1][col]);\n    //push node below current cell \n    if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\n    //push node to the left of current cell \n    if (col > 0) neighbors.push(grid[row][col - 1]);\n    //push node to the right of current cell\n    if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\n    //return neighbors.filter(neighbor => !neighbor.isVisited);\n    return neighbors \n  }\n\n  function BinaryHeap(scoreFunction){\n    this.content = [];\n    this.scoreFunction = scoreFunction;\n  }\n  \n  BinaryHeap.prototype = {\n    push: function(element) {\n      // Add the new element to the end of the array.\n      this.content.push(element);\n      // Allow it to bubble up.\n      this.bubbleUp(this.content.length - 1);\n    },\n  \n    pop: function() {\n      // Store the first element so we can return it later.\n      var result = this.content[0];\n      // Get the element at the end of the array.\n      var end = this.content.pop();\n      // If there are any elements left, put the end element at the\n      // start, and let it sink down.\n      if (this.content.length > 0) {\n        this.content[0] = end;\n        this.sinkDown(0);\n      }\n      return result;\n    },\n  \n    remove: function(node) {\n      var length = this.content.length;\n      // To remove a value, we must search through the array to find\n      // it.\n      for (var i = 0; i < length; i++) {\n        if (this.content[i] != node) continue;\n        // When it is found, the process seen in 'pop' is repeated\n        // to fill up the hole.\n        var end = this.content.pop();\n        // If the element we popped was the one we needed to remove,\n        // we're done.\n        if (i == length - 1) break;\n        // Otherwise, we replace the removed element with the popped\n        // one, and allow it to float up or sink down as appropriate.\n        this.content[i] = end;\n        this.bubbleUp(i);\n        this.sinkDown(i);\n        break;\n      }\n    },\n  \n    size: function() {\n      return this.content.length;\n    },\n\n    rescoreElement: function(node) {\n      this.sinkDown(this.content.indexOf(node));\n    },\n\n    bubbleUp: function(n) {\n      // Fetch the element that has to be moved.\n      var element = this.content[n], score = this.scoreFunction(element);\n      // When at 0, an element can not go up any further.\n      while (n > 0) {\n        // Compute the parent element's index, and fetch it.\n        var parentN = Math.floor((n + 1) / 2) - 1,\n        parent = this.content[parentN];\n        // If the parent has a lesser score, things are in order and we\n        // are done.\n        if (score >= this.scoreFunction(parent))\n          break;\n  \n        // Otherwise, swap the parent with the current element and\n        // continue.\n        this.content[parentN] = element;\n        this.content[n] = parent;\n        n = parentN;\n      }\n    },\n  \n    sinkDown: function(n) {\n      // Look up the target element and its score.\n      var length = this.content.length,\n      element = this.content[n],\n      elemScore = this.scoreFunction(element);\n  \n      while(true) {\n        // Compute the indices of the child elements.\n        var child2N = (n + 1) * 2, child1N = child2N - 1;\n        // This is used to store the new position of the element,\n        // if any.\n        var swap = null;\n        // If the first child exists (is inside the array)...\n        if (child1N < length) {\n          // Look it up and compute its score.\n          var child1 = this.content[child1N],\n          child1Score = this.scoreFunction(child1);\n          // If the score is less than our element's, we need to swap.\n          if (child1Score <= elemScore)\n            swap = child1N;\n        }\n        // Do the same checks for the other child.\n        if (child2N < length) {\n          var child2 = this.content[child2N],\n          child2Score = this.scoreFunction(child2);\n          if (child2Score <= (swap == null ? elemScore : child1Score))\n            swap = child2N;\n        }\n  \n        // No need to swap further, we are done.\n        if (swap == null) break;\n  \n        // Otherwise, swap and continue.\n        this.content[n] = this.content[swap];\n        this.content[swap] = element;\n        n = swap;\n      }\n    }\n  }\n\n\n  \n  function getAllNodes(grid) {\n    const nodes = [];\n    for (const row of grid) {\n      for (const node of row) {\n        nodes.push(node);\n      }\n    }\n    return nodes;\n  }\n  \n  // Backtracks from the finishNode to find the shortest path.\n  export function getNodesInShortestPathOrderDijkstra(finishNode) {\n    const nodesInShortestPathOrder = [];\n    let currentNode = finishNode;\n    while (currentNode !== null) {\n      nodesInShortestPathOrder.unshift(currentNode);\n      currentNode.isShortestPath = true\n      currentNode = currentNode.previousNode;\n    }\n    return nodesInShortestPathOrder;\n  }","/Users/gilbertosanchez/pathfinder_visualizer/src/algorithms/bfs.js",[],["78","79"],"/Users/gilbertosanchez/pathfinder_visualizer/src/Notification/Carousel.js",[],["80","81"],"/Users/gilbertosanchez/pathfinder_visualizer/src/Notification/Items.js",[],"/Users/gilbertosanchez/pathfinder_visualizer/src/Notification/Slider.js",[],["82","83"],"/Users/gilbertosanchez/pathfinder_visualizer/src/PathfindingVisualizer/PathfindingVisualizer.jsx",["84","85","86"],"/Users/gilbertosanchez/pathfinder_visualizer/src/algorithms/astar.js",["87","88"],"//astar algo\n//need to add the (g,f,h) properties to each node \n//g - cost of path\n//h - distance from current node to end node\n//f - g+h\n\nexport function astar(grid, startNode, finishNode) {\n    const visitedNodes = [];\n    startNode.h = heuristicManhattan(startNode, finishNode)\n    startNode.g = 0\n\n    let openHeap = new BinaryHeap(function (node) {return node.f});\n    openHeap.push(startNode)\n    while (!!openHeap.content.length){\n      //use heap to get the node with the lowest cost\n      const currentNode = openHeap.pop();\n      currentNode.closed = true\n      visitedNodes.push(currentNode)\n      if (currentNode === finishNode) return visitedNodes\n      \n      openHeap = updateUnvisitedNeighbors(currentNode, grid, finishNode, openHeap)\n\n    }\n    return visitedNodes;\n}\n\n\n\n    function heuristicManhattan(pos0, pos1) {\n        const d1 = Math.abs(pos1.row - pos0.row);\n        const d2 = Math.abs(pos1.col - pos0.col);\n        return d1 + d2;\n      }\n\n    function updateUnvisitedNeighbors(node, grid, end, heap) {\n      const unvisitedNeighbors = getUnvisitedNeighbors(node, grid);\n      for (const neighbor of unvisitedNeighbors) {\n        if (neighbor.closed || neighbor.isWall) continue;\n        let newGScore = node.g + neighbor.weight\n        const beenVisited = neighbor.isVisited\n        if (neighbor.isVisited === false || newGScore<neighbor.g){\n          neighbor.isVisited = true\n          neighbor.g = newGScore\n          neighbor.previousNode = node;\n          neighbor.h = heuristicManhattan(neighbor, end);\n          neighbor.f = neighbor.g + neighbor.h\n\n          if (!beenVisited){\n            heap.push(neighbor);\n          }else {\n            heap.rescoreElement(neighbor);\n          }\n        }\n\n      }\n\n      return heap;\n    }\n    \n    function getUnvisitedNeighbors(node, grid) {\n      const neighbors = [];\n      const {col, row} = node;\n      //push node above current cell\n      if (row > 0) neighbors.push(grid[row - 1][col]);\n      //push node below current cell \n      if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\n      //push node to the left of current cell \n      if (col > 0) neighbors.push(grid[row][col - 1]);\n      //push node to the right of current cell\n      if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\n      return neighbors; \n    }\n\n\n    function BinaryHeap(scoreFunction){\n      this.content = [];\n      this.scoreFunction = scoreFunction;\n    }\n    \n    BinaryHeap.prototype = {\n      push: function(element) {\n        // Add the new element to the end of the array.\n        this.content.push(element);\n        // Allow it to bubble up.\n        this.bubbleUp(this.content.length - 1);\n      },\n    \n      pop: function() {\n        // Store the first element so we can return it later.\n        var result = this.content[0];\n        // Get the element at the end of the array.\n        var end = this.content.pop();\n        // If there are any elements left, put the end element at the\n        // start, and let it sink down.\n        if (this.content.length > 0) {\n          this.content[0] = end;\n          this.sinkDown(0);\n        }\n        return result;\n      },\n    \n      remove: function(node) {\n        var length = this.content.length;\n        // To remove a value, we must search through the array to find\n        // it.\n        for (var i = 0; i < length; i++) {\n          if (this.content[i] != node) continue;\n          // When it is found, the process seen in 'pop' is repeated\n          // to fill up the hole.\n          var end = this.content.pop();\n          // If the element we popped was the one we needed to remove,\n          // we're done.\n          if (i == length - 1) break;\n          // Otherwise, we replace the removed element with the popped\n          // one, and allow it to float up or sink down as appropriate.\n          this.content[i] = end;\n          this.bubbleUp(i);\n          this.sinkDown(i);\n          break;\n        }\n      },\n    \n      size: function() {\n        return this.content.length;\n      },\n\n      rescoreElement: function(node) {\n        this.sinkDown(this.content.indexOf(node));\n      },\n\n      bubbleUp: function(n) {\n        // Fetch the element that has to be moved.\n        var element = this.content[n], score = this.scoreFunction(element);\n        // When at 0, an element can not go up any further.\n        while (n > 0) {\n          // Compute the parent element's index, and fetch it.\n          var parentN = Math.floor((n + 1) / 2) - 1,\n          parent = this.content[parentN];\n          // If the parent has a lesser score, things are in order and we\n          // are done.\n          if (score > this.scoreFunction(parent))\n            break;\n    \n          // Otherwise, swap the parent with the current element and\n          // continue.\n          this.content[parentN] = element;\n          this.content[n] = parent;\n          n = parentN;\n        }\n      },\n    \n      sinkDown: function(n) {\n        // Look up the target element and its score.\n        var length = this.content.length,\n        element = this.content[n],\n        elemScore = this.scoreFunction(element);\n    \n        while(true) {\n          // Compute the indices of the child elements.\n          var child2N = (n + 1) * 2, child1N = child2N - 1;\n          // This is used to store the new position of the element,\n          // if any.\n          var swap = null;\n          // If the first child exists (is inside the array)...\n          if (child1N < length) {\n            // Look it up and compute its score.\n            var child1 = this.content[child1N],\n            child1Score = this.scoreFunction(child1);\n            // If the score is less than our element's, we need to swap.\n            if (child1Score < elemScore)\n              swap = child1N;\n          }\n          // Do the same checks for the other child.\n          if (child2N < length) {\n            var child2 = this.content[child2N],\n            child2Score = this.scoreFunction(child2);\n            if (child2Score < (swap == null ? elemScore : child1Score))\n              swap = child2N;\n          }\n    \n          // No need to swap further, we are done.\n          if (swap == null) break;\n    \n          // Otherwise, swap and continue.\n          this.content[n] = this.content[swap];\n          this.content[swap] = element;\n          n = swap;\n        }\n      }\n    }\n    \n  // Backtracks from the finishNode to find the shortest path.\n  export function getNodesInShortestPathOrderAstar(finishNode) {\n    const nodesInShortestPathOrder = [];\n    let currentNode = finishNode;\n    while (currentNode !== null) {\n      nodesInShortestPathOrder.unshift(currentNode);\n      currentNode.isShortestPath = true;\n      currentNode = currentNode.previousNode;\n    }\n    return nodesInShortestPathOrder;\n  }\n\n",["89","90"],"/Users/gilbertosanchez/pathfinder_visualizer/src/reportWebVitals.js",[],["91","92"],"/Users/gilbertosanchez/pathfinder_visualizer/src/Maze/recursiveDivMaze.js",[],["93","94"],"/Users/gilbertosanchez/pathfinder_visualizer/src/PathfindingVisualizer/Node/Node.jsx",[],["95","96"],"/Users/gilbertosanchez/pathfinder_visualizer/src/algorithms/dfs.js",[],"/Users/gilbertosanchez/pathfinder_visualizer/src/index.js",[],["97","98"],"/Users/gilbertosanchez/pathfinder_visualizer/src/Notepad/MessageForm.js",[],"/Users/gilbertosanchez/pathfinder_visualizer/src/Notepad/MessageBoard.js",[],{"ruleId":"99","replacedBy":"100"},{"ruleId":"101","replacedBy":"102"},{"ruleId":"103","severity":1,"message":"104","line":94,"column":29,"nodeType":"105","messageId":"106","endLine":94,"endColumn":31},{"ruleId":"103","severity":1,"message":"107","line":100,"column":15,"nodeType":"105","messageId":"106","endLine":100,"endColumn":17},{"ruleId":"108","severity":1,"message":"109","line":181,"column":12,"nodeType":"110","messageId":"111","endLine":181,"endColumn":23},{"ruleId":"99","replacedBy":"112"},{"ruleId":"101","replacedBy":"113"},{"ruleId":"99","replacedBy":"114"},{"ruleId":"101","replacedBy":"115"},{"ruleId":"99","replacedBy":"116"},{"ruleId":"101","replacedBy":"117"},{"ruleId":"103","severity":1,"message":"107","line":381,"column":23,"nodeType":"105","messageId":"106","endLine":381,"endColumn":25},{"ruleId":"103","severity":1,"message":"107","line":405,"column":36,"nodeType":"105","messageId":"106","endLine":405,"endColumn":38},{"ruleId":"103","severity":1,"message":"107","line":428,"column":36,"nodeType":"105","messageId":"106","endLine":428,"endColumn":38},{"ruleId":"103","severity":1,"message":"104","line":107,"column":31,"nodeType":"105","messageId":"106","endLine":107,"endColumn":33},{"ruleId":"103","severity":1,"message":"107","line":113,"column":17,"nodeType":"105","messageId":"106","endLine":113,"endColumn":19},{"ruleId":"99","replacedBy":"118"},{"ruleId":"101","replacedBy":"119"},{"ruleId":"99","replacedBy":"120"},{"ruleId":"101","replacedBy":"121"},{"ruleId":"99","replacedBy":"122"},{"ruleId":"101","replacedBy":"123"},{"ruleId":"99","replacedBy":"124"},{"ruleId":"101","replacedBy":"125"},{"ruleId":"99","replacedBy":"126"},{"ruleId":"101","replacedBy":"127"},"no-native-reassign",["128"],"no-negated-in-lhs",["129"],"eqeqeq","Expected '!==' and instead saw '!='.","BinaryExpression","unexpected","Expected '===' and instead saw '=='.","no-unused-vars","'getAllNodes' is defined but never used.","Identifier","unusedVar",["128"],["129"],["128"],["129"],["128"],["129"],["128"],["129"],["128"],["129"],["128"],["129"],["128"],["129"],["128"],["129"],"no-global-assign","no-unsafe-negation"]